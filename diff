--- 4wm.c	2015-05-31 16:13:16.813013775 -0500
+++ /home/dct/Temp/FrankenWM/frankenwm.c	2015-05-31 16:03:12.432127335 -0500
@@ -1,1217 +1,714 @@
-// see license for copyright and license 
+/* see license for copyright and license */
 
-#include "4wm.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <err.h>
+#include <stdarg.h>
+#include <stdbool.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+#include <regex.h>
+#include <sys/wait.h>
+#include <X11/keysym.h>
+#include <xcb/xcb.h>
+#include <xcb/xcb_atom.h>
+#include <xcb/xcb_icccm.h>
+#include <xcb/xcb_keysyms.h>
+#include <xcb/xcb_ewmh.h>
+
+/* set this to 1 to enable debug prints */
+#if 1
+#  define DEBUG(x)      puts(x);
+#  define DEBUGP(x, ...) printf(x, ##__VA_ARGS__);
+#else
+#  define DEBUG(x);
+#  define DEBUGP(x, ...);
+#endif
+
+/* upstream compatility */
+#define True  true
+#define False false
+#define Mod1Mask     XCB_MOD_MASK_1
+#define Mod4Mask     XCB_MOD_MASK_4
+#define ShiftMask    XCB_MOD_MASK_SHIFT
+#define ControlMask  XCB_MOD_MASK_CONTROL
+#define Button1      XCB_BUTTON_INDEX_1
+#define Button2      XCB_BUTTON_INDEX_2
+#define Button3      XCB_BUTTON_INDEX_3
+#define XCB_MOVE_RESIZE XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y | XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT
+#define XCB_MOVE        XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y
+#define XCB_RESIZE      XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT
+
+static char *WM_ATOM_NAME[]   = { "WM_PROTOCOLS", "WM_DELETE_WINDOW" };
+enum { WM_PROTOCOLS, WM_DELETE_WINDOW, WM_COUNT };
+
+static char *NET_ATOM_NAME[]  = { "_NET_SUPPORTED",
+                                  "_NET_WM_STATE_FULLSCREEN",
+                                  "_NET_WM_STATE",
+                                  "_NET_SUPPORTING_WM_CHECK",
+                                  "_NET_ACTIVE_WINDOW",
+                                  "_NET_NUMBER_OF_DESKTOPS",
+                                  "_NET_CURRENT_DESKTOP",
+                                  "_NET_DESKTOP_GEOMETRY",
+                                  "_NET_DESKTOP_VIEWPORT",
+                                  "_NET_WORKAREA",
+                                  "_NET_SHOWING_DESKTOP",
+                                  "_NET_CLOSE_WINDOW",
+                                  "_NET_WM_WINDOW_TYPE" };
+enum { NET_SUPPORTED,
+       NET_FULLSCREEN,
+       NET_WM_STATE,
+       NET_SUPPORTING_WM_CHECK,
+       NET_ACTIVE,
+       NET_NUMBER_OF_DESKTOPS,
+       NET_CURRENT_DESKTOP,
+       NET_DESKTOP_GEOMETRY,
+       NET_DESKTOP_VIEWPORT,
+       NET_WORKAREA,
+       NET_SHOWING_DESKTOP,
+       NET_CLOSE_WINDOW,
+       NET_WM_WINDOW_TYPE,
+       NET_COUNT };
+
+#define LENGTH(x) (sizeof(x)/sizeof(*x))
+#define CLEANMASK(mask) (mask & ~(numlockmask | XCB_MOD_MASK_LOCK))
+#define BUTTONMASK      XCB_EVENT_MASK_BUTTON_PRESS|XCB_EVENT_MASK_BUTTON_RELEASE
+#define ISFFTM(c)        (c->isfullscrn || c->isfloating || c->istransient || c->isminimized)
+#define USAGE           "usage: frankenwm [-h] [-v]"
+
+enum { RESIZE, MOVE };
+enum { TILE, MONOCLE, BSTACK, GRID, FIBONACCI, DUALSTACK, EQUAL, MODES };
+
+/* argument structure to be passed to function by config.h
+ * com  - a command to run
+ * i    - an integer to indicate different states
+ */
+typedef union {
+    const char **com;
+    const int i;
+} Arg;
+
+/* a key struct represents a combination of
+ * mod      - a modifier mask
+ * keysym   - and the key pressed
+ * func     - the function to be triggered because of the above combo
+ * arg      - the argument to the function
+ */
+typedef struct {
+    unsigned int mod;
+    xcb_keysym_t keysym;
+    void (*func)(const Arg *);
+    const Arg arg;
+} key;
+
+/* a button struct represents a combination of
+ * mask     - a modifier mask
+ * button   - and the mouse button pressed
+ * func     - the function to be triggered because of the above combo
+ * arg      - the argument to the function
+ */
+typedef struct {
+    unsigned int mask, button;
+    void (*func)(const Arg *);
+    const Arg arg;
+} Button;
+
+/* a client is a wrapper to a window that additionally
+ * holds some properties for that window
+ *
+ * next        - the client after this one, or NULL if the current is the last
+ *               client
+ * isurgent    - set when the window received an urgent hint
+ * istransient - set when the window is transient
+ * isfullscrn  - set when the window is fullscreen
+ * isfloating  - set when the window is floating
+ * win         - the window this client is representing
+ *
+ * istransient is separate from isfloating as floating window can be reset
+ * to their tiling positions, while the transients will always be floating
+ */
+typedef struct client {
+    struct client *next;
+    bool isurgent, istransient, isfullscrn, isfloating, isminimized;
+    xcb_window_t win;
+    unsigned int dim[2];
+} client;
+
+/* properties of each desktop
+ * master_size  - the size of the master window
+ * mode         - the desktop's tiling layout mode
+ * growth       - growth factor of the first stack window
+ * head         - the start of the client list
+ * current      - the currently highlighted window
+ * prevfocus    - the client that previously had focus
+ * showpanel    - the visibility status of the panel
+ */
+typedef struct {
+    int mode, growth, gaps;
+    float master_size;
+    client *head, *current, *prevfocus;
+    bool showpanel, invert;
+} desktop;
+
+/* filo for minimized clients */
+typedef struct filo {
+    client *c;
+    struct filo *next;
+} filo;
 
-// variables
-static bool running = true;
-static int randrbase, retval = 0, nmons = 0;
-static unsigned int numlockmask = 0, win_unfocus, win_focus, win_outer, win_urgent, win_trn, win_flt;
+/* define behavior of certain applications
+ * configured in config.h
+ * class    - the class or name of the instance
+ * desktop  - what desktop it should be spawned at
+ * follow   - whether to change desktop focus to the specified desktop
+ */
+typedef struct {
+    const char *class;
+    const int desktop;
+    const bool follow, floating;
+} AppRule;
+
+ /* function prototypes sorted alphabetically */
+static client *addwindow(xcb_window_t w);
+static void adjust_borders(const Arg *arg);
+static void adjust_gaps(const Arg *arg);
+static void buttonpress(xcb_generic_event_t *e);
+static void change_desktop(const Arg *arg);
+static void centerwindow();
+static void cleanup(void);
+static void client_to_desktop(const Arg *arg);
+static void clientmessage(xcb_generic_event_t *e);
+static void configurerequest(xcb_generic_event_t *e);
+static void deletewindow(xcb_window_t w);
+static void desktopinfo(void);
+static void destroynotify(xcb_generic_event_t *e);
+static void dualstack(int hh, int cy);
+static void enternotify(xcb_generic_event_t *e);
+static void equal(int h, int y);
+static void fibonacci(int h, int y);
+static void float_client(client *c);
+static void float_x(const Arg *arg);
+static void float_y(const Arg *arg);
+static void focusmaster();
+static void focusurgent();
+static unsigned int getcolor(char *color);
+static void grabbuttons(client *c);
+static void grabkeys(void);
+static void grid(int h, int y);
+static void invertstack();
+static void keypress(xcb_generic_event_t *e);
+static void killclient();
+static void last_desktop();
+static void maprequest(xcb_generic_event_t *e);
+static void maximize();
+static void minimize();
+static void monocle(int h, int y);
+static void move_down();
+static void move_up();
+static void mousemotion(const Arg *arg);
+static void next_win();
+static client *prev_client();
+static void prev_win();
+static void propertynotify(xcb_generic_event_t *e);
+static void quit(const Arg *arg);
+static void removeclient(client *c);
+static void resize_master(const Arg *arg);
+static void resize_stack(const Arg *arg);
+static void resize_x(const Arg *arg);
+static void resize_y(const Arg *arg);
+static void restore();
+static void rotate(const Arg *arg);
+static void rotate_client(const Arg *arg);
+static void rotate_filled(const Arg *arg);
+static void rotate_mode(const Arg *arg);
+static void run(void);
+static void save_desktop(int i);
+static void select_desktop(int i);
+static void setfullscreen(client *c, bool fullscrn);
+static int setup(int default_screen);
+static void showhide();
+static void sigchld();
+static void spawn(const Arg *arg);
+static void stack(int h, int y);
+static void swap_master();
+static void switch_mode(const Arg *arg);
+static void tile(void);
+static void tilemize();
+static void togglepanel();
+static void unfloat_client(client *c);
+static void togglescratchpad();
+static void update_current(client *c);
+static void unmapnotify(xcb_generic_event_t *e);
+static client *wintoclient(xcb_window_t w);
+
+#include "config.h"
+
+/* variables */
+static bool running = true, showpanel = SHOW_PANEL, show = true,
+            invert = INVERT, showscratchpad = false;
+static int default_screen, previous_desktop, current_desktop, retval;
+static int wh, ww, mode = DEFAULT_MODE, master_size, growth, borders, gaps;
+static unsigned int numlockmask, win_unfocus, win_focus;
 static xcb_connection_t *dis;
 static xcb_screen_t *screen;
+static client *head = NULL, *prevfocus = NULL, *current = NULL, *scrpd = NULL;
+
+static xcb_ewmh_connection_t *ewmh;
 static xcb_atom_t wmatoms[WM_COUNT], netatoms[NET_COUNT];
 static desktop desktops[DESKTOPS];
-static monitor *mons = NULL, *selmon = NULL;
-#if MENU
-static Menu *menus = NULL;
-static Xresources xres;
-#endif
-#if PRETTY_PRINT
-pp_data pp;
-#endif
+static filo *miniq[DESKTOPS];
+static regex_t appruleregex[LENGTH(rules)];
 
-// events array on receival of a new event, call the appropriate function to handle it
-void (*events[XCB_NO_OPERATION])(xcb_generic_event_t *e);
+/* events array
+ * on receival of a new event, call the appropriate function to handle it
+ */
+static void (*events[XCB_NO_OPERATION])(xcb_generic_event_t *e);
+
+/* layout array - given the current layout mode, tile the windows
+ * h (or hh) - avaible height that windows have to expand
+ * y (or cy) - offset from top to place the windows (reserved by the panel) */
+static void (*layout[MODES])(int h, int y) = {
+    [TILE] = stack,
+    [BSTACK] = stack,
+    [GRID] = grid,
+    [MONOCLE] = monocle,
+    [FIBONACCI] = fibonacci,
+    [DUALSTACK] = dualstack,
+    [EQUAL] = equal,
+};
 
-/* wrapper to move and resize window */
-inline void xcb_move_resize(xcb_connection_t *con, xcb_window_t win, int x, int y, int w, int h) {
-    unsigned int pos[4] = { x, y, w, h };
-    xcb_configure_window(con, win, XCB_MOVE_RESIZE, pos);
-}
+/* get screen of display */
+static xcb_screen_t *xcb_screen_of_display(xcb_connection_t *con, int screen)
+{
+    xcb_screen_iterator_t iter;
 
-bool (*findtouchingclients[TDIRECS])(desktop *d, client *c, client **list, int *num) = {
-    [TBOTTOM] = clientstouchingbottom, [TLEFT] = clientstouchingleft, [TRIGHT] = clientstouchingright, [TTOP] = clientstouchingtop,
-};
+    iter = xcb_setup_roots_iterator(xcb_get_setup(con));
+    for (; iter.rem; --screen, xcb_screen_next(&iter))
+        if (screen == 0)
+            return iter.data;
 
-void (*tiledirection[TDIRECS])(client *n, client *c) = {
-    [TBOTTOM] = tilenewbottom, [TLEFT] = tilenewleft, [TRIGHT] = tilenewright, [TTOP] = tilenewtop,
-};
+    return NULL;
+}
 
-// COMMANDS 
+/* wrapper to move and resize window */
+static inline void xcb_move_resize(xcb_connection_t *con, xcb_window_t win,
+                                   int x, int y, int w, int h)
+{
+    unsigned int pos[4] = { x, y, w, h };
 
-#define XCB_MOVE        XCB_CONFIG_WINDOW_X | XCB_CONFIG_WINDOW_Y
-#define XCB_RESIZE      XCB_CONFIG_WINDOW_WIDTH | XCB_CONFIG_WINDOW_HEIGHT
+    xcb_configure_window(con, win, XCB_MOVE_RESIZE, pos);
+}
 
-// wrapper to move window
-static inline void xcb_move(xcb_connection_t *con, xcb_window_t win, int x, int y) {
+/* wrapper to move window */
+static inline void xcb_move(xcb_connection_t *con, xcb_window_t win, int x,
+                            int y)
+{
     unsigned int pos[2] = { x, y };
+
     xcb_configure_window(con, win, XCB_MOVE, pos);
 }
 
-// wrapper to resize window
-static inline void xcb_resize(xcb_connection_t *con, xcb_window_t win, int w, int h) {
+/* wrapper to resize window */
+static inline void xcb_resize(xcb_connection_t *con, xcb_window_t win, int w,
+                              int h)
+{
     unsigned int pos[2] = { w, h };
-    xcb_configure_window(con, win, XCB_RESIZE, pos);
-}
 
-// wrapper to lower window
-static inline void xcb_lower_window(xcb_connection_t *con, xcb_window_t win) {
-    unsigned int arg[1] = { XCB_STACK_MODE_BELOW };
-    xcb_configure_window(con, win, XCB_CONFIG_WINDOW_STACK_MODE, arg);
+    xcb_configure_window(con, win, XCB_RESIZE, pos);
 }
 
-// wrapper to raise window
-static inline void xcb_raise_window(xcb_connection_t *con, xcb_window_t win) {
+/* wrapper to raise window */
+static inline void xcb_raise_window(xcb_connection_t *con, xcb_window_t win)
+{
     unsigned int arg[1] = { XCB_STACK_MODE_ABOVE };
-    xcb_configure_window(con, win, XCB_CONFIG_WINDOW_STACK_MODE, arg);
-}
 
-static void growbyh(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->hp = match ? (match->yp - c->yp):(c->hp + size);
-    xcb_move_resize(dis, c->win, c->x, c->y, c->w, (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-    setclientborders(d, c, m);
+    xcb_configure_window(con, win, XCB_CONFIG_WINDOW_STACK_MODE, arg);
 }
 
-static void growbyw(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->wp = match ? (match->xp - c->xp):(c->wp + size);
-    xcb_move_resize(dis, c->win, c->x, c->y, (c->w  = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), c->h);
-    setclientborders(d, c, m);
+/* wrapper to set xcb border width */
+static inline void xcb_border_width(xcb_connection_t *con, xcb_window_t win,
+                                    int w)
+{
+    unsigned int arg[1] = { w };
+
+    xcb_configure_window(con, win, XCB_CONFIG_WINDOW_BORDER_WIDTH, arg);
 }
 
-static void growbyx(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->wp = match ? ((c->xp + c->wp) - (match->xp + match->wp)):(c->wp + size);
-    c->xp = match ? (match->xp + match->wp):(c->xp - size);
-    xcb_move_resize(dis, c->win, (c->x = m->x + (m->w * c->xp) + c->gapx), c->y, 
-                    (c->w  = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), c->h);
-    setclientborders(d, c, m);
-}
+/* wrapper to get xcb keysymbol from keycode */
+static xcb_keysym_t xcb_get_keysym(xcb_keycode_t keycode)
+{
+    xcb_key_symbols_t *keysyms;
+    xcb_keysym_t       keysym;
 
-static void growbyy(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->hp = match ? ((c->yp + c->hp) - (match->yp + match->hp)):(c->hp + size);
-    c->yp = match ? (match->yp + match->hp):(c->yp - size);
-    xcb_move_resize(dis, c->win, c->x, (c->y = m->y + (m->h * c->yp) + c->gapy), 
-                    c->w, (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-    setclientborders(d, c, m);
-}
+    if (!(keysyms = xcb_key_symbols_alloc(dis)))
+        return 0;
+    keysym = xcb_key_symbols_get_keysym(keysyms, keycode, 0);
+    xcb_key_symbols_free(keysyms);
 
-static void shrinkbyh(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->hp = match ? (match->yp - c->yp):(c->hp - size);
-    xcb_move_resize(dis, c->win, c->x, c->y, c->w, (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-    setclientborders(d, c, m);
+    return keysym;
 }
 
-static void shrinkbyw(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->wp = match ? (match->xp - c->xp):(c->wp - size);
-    xcb_move_resize(dis, c->win, c->x, c->y, (c->w  = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), c->h);
-    setclientborders(d, c, m);
-}
+/* wrapper to get xcb keycodes from keysymbol (caller must free) */
+static xcb_keycode_t *xcb_get_keycodes(xcb_keysym_t keysym)
+{
+    xcb_key_symbols_t *keysyms;
+    xcb_keycode_t     *keycode;
 
-static void shrinkbyx(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->wp = match ? ((c->xp + c->wp) - (match->xp + match->wp)):(c->wp - size);
-    c->xp = match ? (match->xp + match->wp):(c->xp + size);
-    xcb_move_resize(dis, c->win, (c->x = m->x + (m->w * c->xp) + c->gapx), c->y, 
-                    (c->w  = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), c->h);
-    setclientborders(d, c, m);
-}
+    if (!(keysyms = xcb_key_symbols_alloc(dis)))
+        return NULL;
+    keycode = xcb_key_symbols_get_keycode(keysyms, keysym);
+    xcb_key_symbols_free(keysyms);
 
-static void shrinkbyy(client *match, const float size, client *c, const monitor *m, desktop *d) {
-    c->hp = match ? ((c->yp + c->hp) - (match->yp + match->hp)):(c->hp - size);
-    c->yp = match ? (match->yp + match->hp):(c->yp + size);
-    xcb_move_resize(dis, c->win, c->x, (c->y = m->y + (m->h * c->yp) + c->gapy), 
-                    c->w, (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-    setclientborders(d, c, m);
+    return keycode;
 }
 
-#if MENU
-static void text_draw (xcb_gcontext_t gc, xcb_window_t window, int16_t x1, int16_t y1, const char *label) {
-    //xcb_void_cookie_t    cookie_gc;
-    xcb_void_cookie_t    cookie_text;
-    xcb_generic_error_t *error;
-    uint8_t              length;
-
-    length = strlen(label);
+/* retieve RGB color from hex (think of html) */
+static unsigned int xcb_get_colorpixel(char *hex)
+{
+    char strgroups[3][3]  = {{hex[1], hex[2], '\0'},
+                             {hex[3], hex[4], '\0'},
+                             {hex[5], hex[6], '\0'}};
+    unsigned int rgb16[3] = {(strtol(strgroups[0], NULL, 16)),
+                             (strtol(strgroups[1], NULL, 16)),
+                             (strtol(strgroups[2], NULL, 16))};
 
-    cookie_text = xcb_image_text_8_checked(dis, length, window, gc, x1, y1, label);
-    error = xcb_request_check(dis, cookie_text);
-    if (error) {
-        fprintf(stderr, "ERROR: can't paste text : %d\n", error->error_code);
-        xcb_disconnect(dis);
-        exit(-1);
-    }
+    return (rgb16[0] << 16) + (rgb16[1] << 8) + rgb16[2];
 }
-#endif
 
-// focus another desktop
-//
-// to avoid flickering
-// first map the new windows
-// first the current window and then all other
-// then unmap the old windows
-// first all others then the current
-void change_desktop(const Arg *arg) {  
-    DEBUG("change_desktop: Entered\n"); 
-    int i;
-
-    if (arg->i == selmon->curr_dtop || arg->i < 0 || arg->i >= DESKTOPS) { 
-        DEBUG("change_desktop: not a valid desktop or the same desktop\n");
-        return;
-    }
- 
-    bool flag = false; monitor *m = NULL;
-    for (i = 0, m = mons; i < nmons; m = m->next, i++)
-        if ((m->curr_dtop == arg->i) && m != selmon) {
-            m->curr_dtop = selmon->curr_dtop;
-            flag = true;
-            break;
-        }
+/* wrapper to get atoms using xcb */
+static void xcb_get_atoms(char **names, xcb_atom_t *atoms, unsigned int count)
+{
+    xcb_intern_atom_cookie_t cookies[count];
+    xcb_intern_atom_reply_t  *reply;
 
-    desktop *d = &desktops[(selmon->curr_dtop)], *n = &desktops[(selmon->curr_dtop = arg->i)];
-    
-    if (flag) { // desktop exists on another monitor
-        DEBUG("change_desktop: tiling current monitor, new desktop\n");
-        retile(n, selmon);
-        
-        DEBUG("change_desktop: tiling other monitor, old desktop\n");
-        retile(d, m);
-    }
-    else { 
-        DEBUG("change_desktop: retiling new windows on current monitor\n");
-        retile(n, selmon);
-        DEBUG("change_desktop: mapping new windows on current monitor\n"); 
-        if (n->current)
-            xcb_map_window(dis, n->current->win);
-        for (client *c = n->head; c; c = c->next)
-            xcb_map_window(dis, c->win);
- 
-        DEBUG("change_desktop: unmapping old windows on current monitor\n");
-        for (client *c = d->head; c; c = c->next) 
-            if (c != d->current)
-                xcb_unmap_window(dis, c->win);
-        if (d->current)
-            xcb_unmap_window(dis, d->current->win); 
-    } 
-    
-    #if PRETTY_PRINT
-    updatews();
-    updatemode();
-    updatedir();
-    desktopinfo();
-    #endif
-    DEBUG("change_desktop: leaving\n");
-}
+    for (unsigned int i = 0; i < count; i++)
+        cookies[i] = xcb_intern_atom(dis, 0, strlen(names[i]), names[i]);
 
-// move a client to another desktop
-//
-// remove the current client from the current desktop's client list
-// and add it as last client of the new desktop's client list
-void client_to_desktop(const Arg *arg) {
-    DEBUG("client_to_desktop: entering\n");
-
-    if (arg->i == selmon->curr_dtop || arg->i < 0 || arg->i >= DESKTOPS || !desktops[selmon->curr_dtop].current) 
-        return;
-   
-    // see if window will be moving to another monitor
-    bool flag = false; monitor *m = NULL; int i;
-    for (i = 0, m = mons; i < nmons; m = m->next, i++)
-        if ((m->curr_dtop == arg->i) && m != selmon) {
-            flag = true;
-            break;
+    for (unsigned int i = 0; i < count; i++) {
+        reply = xcb_intern_atom_reply(dis, cookies[i], NULL);
+        /* TODO: Handle error */
+        if (reply) {
+            DEBUGP("%s : %d\n", names[i], reply->atom);
+            atoms[i] = reply->atom; free(reply);
+        } else {
+            puts("WARN: frankenwm failed to register %s atom.\nThings might not work right.");
         }
+    }
+}
 
-    desktop *d = &desktops[selmon->curr_dtop], *n = &desktops[arg->i];
-    client *c = d->current, *p = prev_client(d->current, d), *l = prev_client(n->head, n);
-    
-    if (c == d->head || !p) 
-        d->head = c->next; 
-    else 
-        p->next = c->next;
-    c->next = NULL;
-    if (!ISFT(c)) {
-        d->count -= 1;
-        n->count += 1;
-        tileremove(c, d, selmon);
-    }
-    DEBUGP("client_to_desktop: d->count = %d\nclient_to_desktop: n->count = %d\n", d->count, n->count);
-
-    if (!flag) { // window is not moving to another monitor 
-        xcb_unmap_window(dis, c->win);
-    }
- 
-    focus(d->prevfocus, d, selmon);
-    if (l)
-        l->next = c;
-    else if (n->head)
-        n->head->next = c;
-    else
-        n->head = c;  
+/* wrapper to window get attributes using xcb */
+static void xcb_get_attributes(xcb_window_t *windows,
+                               xcb_get_window_attributes_reply_t **reply,
+                               unsigned int count)
+{
+    xcb_get_window_attributes_cookie_t cookies[count];
 
-    m = wintomon(n->head->win);
-    tilenew(n, m); // itll be ok if m == NULL 
-    focus(c, n, m);
-
-    if (FOLLOW_WINDOW) 
-        change_desktop(arg); 
-    
-    #if PRETTY_PRINT
-    updatews();
-    desktopinfo();
-    #endif
-    DEBUG("client_to_desktop: leaving\n");
+    for (unsigned int i = 0; i < count; i++)
+        cookies[i] = xcb_get_window_attributes(dis, windows[i]);
+    for (unsigned int i = 0; i < count; i++)
+        reply[i] = xcb_get_window_attributes_reply(dis, cookies[i], NULL);
+        /* TODO: Handle error */
 }
 
-// decrease gap between windows
-void decreasegap(const Arg *arg) {
-    desktop *d = &desktops[selmon->curr_dtop];
-    if(d->gap > MINGAP) {
-        d->gap -= arg->i;
-        for (client *c = d->head; c; c = c->next)
-            adjustclientgaps(d->gap, c);
-        retile(d, selmon);
-    }
-}
+/* check if other wm exists */
+static int xcb_checkotherwm(void)
+{
+    xcb_generic_error_t *error;
+    unsigned int values[1] = {XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT|
+                              XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY|
+                              XCB_EVENT_MASK_PROPERTY_CHANGE|
+                              XCB_EVENT_MASK_BUTTON_PRESS};
 
-// find and focus the client which received
-// the urgent hint in the current desktop
-void focusurgent() {
-    DEBUG("focusurgent: entering\n");
-    client *c = NULL;
-    int d = -1;
-    for (c=desktops[selmon->curr_dtop].head; c && !c->isurgent; c=c->next);
-    while (!c && d < DESKTOPS-1) 
-        for (c = desktops[++d].head; c && !c->isurgent; c = c->next);
-    if (c) { 
-        change_desktop(&(Arg){.i = --d}); 
-        focus(c, &desktops[selmon->curr_dtop], selmon);
-    }
-
-    DEBUG("focusurgent: leaving\n");
-}
-
-// increase gap between windows
-void increasegap(const Arg *arg) {
-    desktop *d = &desktops[selmon->curr_dtop];
-    if(d->gap < MAXGAP) {
-        d->gap += arg->i;
-        for (client *c = d->head; c; c = c->next)
-            adjustclientgaps(d->gap, c);
-        retile(d, selmon); 
-    }
+    error = xcb_request_check(dis, xcb_change_window_attributes_checked(dis,
+                                    screen->root, XCB_CW_EVENT_MASK, values));
+    xcb_flush(dis);
+    if (error)
+        return 1;
+    return 0;
 }
 
-// explicitly kill a client - close the highlighted window
-// send a delete message and remove the client
-void killclient() {
-    DEBUG("killclient: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    if (!d->current) return;
-    xcb_icccm_get_wm_protocols_reply_t reply; unsigned int n = 0; bool got = false;
-    if (xcb_icccm_get_wm_protocols_reply(dis,
-        xcb_icccm_get_wm_protocols(dis, d->current->win, wmatoms[WM_PROTOCOLS]),
-        &reply, NULL)) { // TODO: Handle error?
-        for(; n != reply.atoms_len; ++n) 
-            if ((got = reply.atoms[n] == wmatoms[WM_DELETE_WINDOW])) 
-                break;
-        xcb_icccm_get_wm_protocols_reply_wipe(&reply);
+/* create a new client and add the new window
+ * window should notify of property change events
+ */
+client *addwindow(xcb_window_t w)
+{
+    client *c, *t = prev_client(head);
+
+    if (!(c = (client *)calloc(1, sizeof(client))))
+         err(EXIT_FAILURE, "cannot allocate client");
+
+    if (!head) {
+        head = c;
+    } else if (!ATTACH_ASIDE) {
+        c->next = head; head = c;
+    } else if (t) {
+        t->next = c;
+    } else {
+        head->next = c;
     }
-    if (got) deletewindow(d->current->win);
-    else xcb_kill_client(dis, d->current->win);
-    DEBUG("killclient: leaving\n");
-}
-
-#if MENU
-void launchmenu(const Arg *arg) {
-    DEBUG("launchmenu: entering\n");
-    xcb_drawable_t win;
-    xcb_generic_event_t *e;
-    uint32_t mask = 0;
-    uint32_t winvalues[1];
-    bool waitforevents = true, found = false; 
-    Menu *m = NULL;
-    int i, x, y;
-
-    //find which menu
-    for (m = menus; m; m = m->next)
-        if (strcmp(m->list[0], arg->list[0]) == 0) {
-            DEBUG("launchmenu: found menu\n");
-            break;
-        }
-    
-    // Create black (foreground) graphic context
-    win = screen->root; 
-
-    // Ask for our window's Id
-    win = xcb_generate_id(dis);
-
-    // Create the window
-    mask = XCB_CW_EVENT_MASK;
-    winvalues[0] = XCB_EVENT_MASK_EXPOSURE;
-    xcb_create_window (dis, XCB_COPY_FROM_PARENT, win, screen->root, selmon->x, 
-                        selmon->y, selmon->w, selmon->h, 0, XCB_WINDOW_CLASS_INPUT_OUTPUT, 
-                        screen->root_visual, mask, winvalues);
-
-    // Map the window on the screen
-    xcb_map_window (dis, win);
-     
-    xcb_change_property(dis, XCB_PROP_MODE_REPLACE, screen->root, netatoms[NET_ACTIVE], XCB_ATOM_WINDOW, 32, 1, &win);
-    xcb_set_input_focus(dis, XCB_INPUT_FOCUS_POINTER_ROOT, win, XCB_CURRENT_TIME);
-    
-    // We flush the request
-    xcb_flush (dis);
 
-    while (waitforevents && (e = xcb_wait_for_event (dis))) {
-        switch (e->response_type & ~0x80) {
-            case XCB_EXPOSE: {
-                DEBUG("launchmenu: entering XCB_EXPOSE\n");
-                // loop through menu_entries
-                i = 0;
-                for (Menu_Entry *mentry = m->head; mentry; mentry = mentry->next) {
-                    DEBUG("launchmenu: drawing iteration\n");
-                    // We draw the rectangles
-                    xcb_poly_fill_rectangle(dis, win, xres.gc_color[i], 1, mentry->rectangles);
-                    // we also want to draw the command/program
-                    text_draw(xres.font_gc[i], win, mentry->x + 10, mentry->y + 30, mentry->cmd[0]);
-                    if (i == 11) i = 0;
-                    else i++;
-                }
-                // We flush the request
-                xcb_flush (dis);
-                break;
-            }
-            case XCB_BUTTON_PRESS: {
-                DEBUG("launchmenu: entering XCB_BUTTON_PRESS\n");
-                waitforevents = false;
-                xcb_unmap_window (dis, win);
-                if (getrootptr(&x, &y)) {
-                x -= selmon->x;
-                y -= selmon->y;
-                DEBUGP("launchmenu: x %d y %d\n", x, y);
-                    for (Menu_Entry *mentry = m->head; mentry; ) {
-                        DEBUGP("launchmenu: mentry->x %d mentry->y %d\n", mentry->x, mentry->y);
-                        if (INRECT(x, y, mentry->x, mentry->y, 100, 60)) { 
-                            found = true;
-                            if (fork()) return;
-                            if (dis) close(screen->root);
-                            setsid();
-                            execvp(mentry->cmd[0], mentry->cmd);
-                            break; // exit loop
-                        }
-                        
-                        if (x < mentry->x) {
-                            if (!mentry->l) break;
-                            else mentry = mentry->l;
-                        } else if (x > mentry->x + 100) { 
-                            if (!mentry->r) break;
-                            else mentry = mentry->r;
-                        }
-                        
-                        if (y < mentry->y) {
-                            if (!mentry->t) break;
-                            else mentry = mentry->t;
-                        } else if (y > mentry->y + 60) {
-                            if (!mentry->b) break;
-                            else mentry = mentry->b;
-                        }
-                    }
-                }
-    
-                if (!found)
-                    focus(desktops[selmon->curr_dtop].current, &desktops[selmon->curr_dtop], selmon);
+    unsigned int values[1] = {XCB_EVENT_MASK_PROPERTY_CHANGE|
+                              (FOLLOW_MOUSE ? XCB_EVENT_MASK_ENTER_WINDOW : 0)};
+    xcb_change_window_attributes_checked(dis, (c->win = w), XCB_CW_EVENT_MASK,
+                                         values);
 
-                break;
-            }
-            case XCB_KEY_RELEASE: {
-                DEBUG("launchmenu: entering XCB_KEY_RELEASE\n");
-                break; 
-            }
-            default: {
-                DEBUG("launchmenu: unknown event\n");
-                // Unknown event type, ignore it
-                break;
-            }
-        }
-        // Free the Generic Event
-        free (e);
-    }
-    DEBUG("launchmenu: leaving\n");
+    return c;
 }
-#endif
-
-// grab the pointer and get it's current position
-// all pointer movement events will be reported until it's ungrabbed
-// until the mouse button has not been released,
-// grab the interesting events - button press/release and pointer motion
-// and on on pointer movement resize or move the window under the curson.
-// if the received event is a map request or a configure request call the
-// appropriate handler, and stop listening for other events.
-// Ungrab the poitner and event handling is passed back to run() function.
-// Once a window has been moved or resized, it's marked as floating.
-void mousemotion(const Arg *arg) {
-    DEBUG("mousemotion: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    client *c = d->current;
-
-    xcb_get_geometry_reply_t  *geometry;
-    xcb_query_pointer_reply_t *pointer;
-    xcb_grab_pointer_reply_t  *grab_reply;
-    int mx, my, winx, winy, winw, winh, xw, yh;
 
-    if (!c) return;
-    geometry = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, c->win), NULL); // TODO: error handling
-    if (geometry) {
-        winx = geometry->x;     winy = geometry->y;
-        winw = geometry->width; winh = geometry->height;
-        free(geometry);
-    } else return;
+/* change the size of the window borders */
+void adjust_borders(const Arg *arg)
+{
+    if (arg->i > 0 || borders >= -arg->i)
+        borders += arg->i;
+    tile();
+    update_current(current);
+}
+
+/* change the size of the useless gaps on the fly and re-tile */
+void adjust_gaps(const Arg *arg)
+{
+    if (arg->i > 0 || gaps >= -arg->i)
+        gaps += arg->i;
+
+    if (GLOBALGAPS)
+        for (int i = 0; i < DESKTOPS; i++)
+            desktops[i].gaps = gaps;
+    else
+        desktops[current_desktop].gaps = gaps;
+    tile();
+}
 
-    pointer = xcb_query_pointer_reply(dis, xcb_query_pointer(dis, screen->root), 0);
-    if (!pointer) return;
-    mx = pointer->root_x; my = pointer->root_y;
-
-    grab_reply = xcb_grab_pointer_reply(dis, xcb_grab_pointer(dis, 0, screen->root, BUTTONMASK|XCB_EVENT_MASK_BUTTON_MOTION|XCB_EVENT_MASK_POINTER_MOTION,
-            XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE, XCB_CURRENT_TIME), NULL);
-    if (!grab_reply || grab_reply->status != XCB_GRAB_STATUS_SUCCESS) return;
+/* on the press of a button check to see if there's a binded function to call */
+void buttonpress(xcb_generic_event_t *e)
+{
+    xcb_button_press_event_t *ev = (xcb_button_press_event_t *)e;
+    DEBUGP("xcb: button press: %d state: %d\n", ev->detail, ev->state);
 
-    // what is probably meant here, is for when FOLLOW_MOUSE is set to false, we will need to focus the client under mouse.
-    //focus(c, d); 
+    client *c = wintoclient(ev->event);
+    if (!c)
+        return;
+    if (CLICK_TO_FOCUS && current != c && ev->detail == XCB_BUTTON_INDEX_1)
+        update_current(c);
 
-    xcb_generic_event_t *e = NULL;
-    xcb_motion_notify_event_t *ev = NULL;
-    bool ungrab = c->isfloating ? false:true;
-    while (!ungrab && c) {
-        if (e) free(e); xcb_flush(dis);
-        while(!(e = xcb_wait_for_event(dis))) xcb_flush(dis);
-        switch (e->response_type & ~0x80) {
-            case XCB_CONFIGURE_REQUEST: case XCB_MAP_REQUEST:
-                events[e->response_type & ~0x80](e);
-                break;
-            case XCB_MOTION_NOTIFY:
-                ev = (xcb_motion_notify_event_t*)e;
-                xw = (arg->i == MOVE ? winx : winw) + ev->root_x - mx;
-                yh = (arg->i == MOVE ? winy : winh) + ev->root_y - my;
-                if (arg->i == RESIZE) { 
-                    xcb_resize(dis, c->win, (c->w = xw>MINWSZ?xw:winw), ( c->h = yh>MINWSZ?yh:winh));
-                    setclientborders(d, d->current, selmon);
-                } else if (arg->i == MOVE) {  
-                    xcb_move(dis, c->win, (c->x = xw), (c->y = yh));
-            
-                    // handle floater moving monitors
-                    if (!INRECT(xw, yh, selmon->x, selmon->y, selmon->w, selmon->h)) {
-                        monitor *m = NULL;
-                        for (m = mons; m && !INRECT(xw, yh, m->x, m->y, m->w, m->h); m = m->next);
-                        if (m) { // we found a monitor
-                            desktop *n = &desktops[m->curr_dtop];
-                            client *p = prev_client(d->current, d), *l = prev_client(n->head, n);
-                            // pull client from desktop
-                            if (c == d->head || !p) 
-                                d->head = c->next; 
-                            else 
-                                p->next = c->next;
-                            c->next = NULL;   
-                            // add to new desktop
-                            if (l)
-                                l->next = c;
-                            else if (n->head)
-                                n->head->next = c;
-                            else
-                                n->head = c;  
-                            monitor *mold = selmon;
-                            selmon = m;
-                            focus(c, n, m); //readjust focus for new desktop
-                            focus(d->prevfocus, d, mold); // readjust the focus from that desktop
-                            d = &desktops[m->curr_dtop];
-                            #if PRETTY_PRINT
-                            updatews();
-                            updatemode();
-                            updatedir();
-                            desktopinfo();
-                            #endif
-                        }
-                    }
-                }
-                xcb_flush(dis);
-                break;
-            case XCB_KEY_PRESS:
-            case XCB_KEY_RELEASE:
-            case XCB_BUTTON_PRESS:
-            case XCB_BUTTON_RELEASE:
-                ungrab = true;
+    for (unsigned int i = 0; i < LENGTH(buttons); i++)
+        if (buttons[i].func && buttons[i].button == ev->detail &&
+            CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state)) {
+            if (current != c)
+                update_current(c);
+            buttons[i].func(&(buttons[i].arg));
         }
+
+    if (CLICK_TO_FOCUS) {
+        xcb_allow_events(dis, XCB_ALLOW_REPLAY_POINTER, ev->time);
+        xcb_flush(dis);
     }
-    xcb_ungrab_pointer(dis, XCB_CURRENT_TIME);
-    DEBUG("mousemotion: leaving\n");
 }
 
-void moveclient(const Arg *arg) {
-    DEBUG("moveclient: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    client *c = d->current, **list; 
-
-    if (!c || c->isfloating) {
-        DEBUG("moveclient: leaving, no d->current or c->isfloating\n");
-        return;
-    }
-
-    if(d->mode == TILE) { //capable of having windows below?
-        int n = d->count;
-        DEBUGP("moveclient: d->count = %d\n", d->count);
-        c = d->current;
-        list = (client**)malloc_safe(n * sizeof(client*));
-        (arg->m)(&n, c, list, d);
-        free(list);
-    }
-    DEBUG("moveclient: leaving\n");
-}
-
-// switch the current client with the first client we find below it
-void moveclientdown(int *num, client *c, client **list, desktop *d) { 
-    DEBUG("moveclientdown: entering\n");
-    client *cold;
-    findtouchingclients[TBOTTOM](d, c, list, num);
-    // switch stuff
-    if (list[0] != NULL) {
-        cold->xp = c->xp; cold->yp = c->yp; cold->wp = c->wp; cold->hp = c->hp;
-        c->xp = list[0]->xp; c->yp = list[0]->yp; c->wp = list[0]->wp; c->hp = list[0]->hp;
-        adjustclientgaps(d->gap, c);
-        list[0]->xp = cold->xp; list[0]->yp = cold->yp; list[0]->wp = cold->wp; list[0]->hp = cold->hp;
-        adjustclientgaps(d->gap, list[0]);
-        // move stuff
-        xcb_move_resize(dis, list[0]->win, 
-                        (list[0]->x = selmon->x + (selmon->w * list[0]->xp) + list[0]->gapx), 
-                        (list[0]->y = selmon->y + (selmon->h * list[0]->yp) + list[0]->gapy), 
-                        (list[0]->w = (selmon->w * list[0]->wp) - 2*BORDER_WIDTH - list[0]->gapx - list[0]->gapw), 
-                        (list[0]->h = (selmon->h * list[0]->hp) - 2*BORDER_WIDTH - list[0]->gapy - list[0]->gaph));
-        xcb_move_resize(dis, c->win, 
-                        (c->x = selmon->x + (selmon->w * c->xp) + c->gapx), 
-                        (c->y = selmon->y + (selmon->h * c->yp) + c->gapy), 
-                        (c->w = (selmon->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), 
-                        (c->h = (selmon->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph)); 
-        setclientborders(d, list[0], selmon);
-        setclientborders(d, c, selmon);
-    }
-    DEBUG("moveclientdown: leaving\n");
-}
-
-// switch the current client with the first client we find to the left of it
-void moveclientleft(int *num, client *c, client **list, desktop *d) { 
-    DEBUG("moveclientleft: entering\n");
-    client *cold; 
-    findtouchingclients[TLEFT](d, c, list, num);
-    // switch stuff
-    if (list[0] != NULL) {
-        cold->xp = c->xp; cold->yp = c->yp; cold->wp = c->wp; cold->hp = c->hp;
-        c->xp = list[0]->xp; c->yp = list[0]->yp; c->wp = list[0]->wp; c->hp = list[0]->hp;
-        adjustclientgaps(d->gap, c);
-        list[0]->xp = cold->xp; list[0]->yp = cold->yp; list[0]->wp = cold->wp; list[0]->hp = cold->hp;
-        adjustclientgaps(d->gap, list[0]);
-        // move stuff
-        xcb_move_resize(dis, list[0]->win, 
-                        (list[0]->x = selmon->x + (selmon->w * list[0]->xp) + list[0]->gapx), 
-                        (list[0]->y = selmon->y + (selmon->h * list[0]->yp) + list[0]->gapy), 
-                        (list[0]->w = (selmon->w * list[0]->wp) - 2*BORDER_WIDTH - list[0]->gapx - list[0]->gapw), 
-                        (list[0]->h = (selmon->h * list[0]->hp) - 2*BORDER_WIDTH - list[0]->gapy - list[0]->gaph));
-        xcb_move_resize(dis, c->win, 
-                        (c->x = selmon->x + (selmon->w * c->xp) + c->gapx), 
-                        (c->y = selmon->y + (selmon->h * c->yp) + c->gapy), 
-                        (c->w = (selmon->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), 
-                        (c->h = (selmon->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-        setclientborders(d, list[0], selmon);
-        setclientborders(d, c, selmon);
-    }
-    DEBUG("moveclientleft: leaving\n");
-}
-
-// switch the current client with the first client we find to the right of it
-void moveclientright(int *num, client *c, client **list, desktop *d) { 
-    DEBUG("moveclientright: entering\n");
-    client *cold;
-    findtouchingclients[TRIGHT](d, c, list, num);
-    // switch stuff
-    if (list[0] != NULL) {
-        cold->xp = c->xp; cold->yp = c->yp; cold->wp = c->wp; cold->hp = c->hp;
-        c->xp = list[0]->xp; c->yp = list[0]->yp; c->wp = list[0]->wp; c->hp = list[0]->hp;
-        adjustclientgaps(d->gap, c);
-        list[0]->xp = cold->xp; list[0]->yp = cold->yp; list[0]->wp = cold->wp; list[0]->hp = cold->hp;
-        adjustclientgaps(d->gap, list[0]);
-        // move stuff
-        xcb_move_resize(dis, list[0]->win, 
-                        (list[0]->x = selmon->x + (selmon->w * list[0]->xp) + list[0]->gapx), 
-                        (list[0]->y = selmon->y + (selmon->h * list[0]->yp) + list[0]->gapy), 
-                        (list[0]->w = (selmon->w * list[0]->wp) - 2*BORDER_WIDTH - list[0]->gapx - list[0]->gapw), 
-                        (list[0]->h = (selmon->h * list[0]->hp) - 2*BORDER_WIDTH - list[0]->gapy - list[0]->gaph));
-        xcb_move_resize(dis, c->win, 
-                        (c->x = selmon->x + (selmon->w * c->xp) + c->gapx), 
-                        (c->y = selmon->y + (selmon->h * c->yp) + c->gapy), 
-                        (c->w = (selmon->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), 
-                        (c->h = (selmon->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-        setclientborders(d, list[0], selmon);
-        setclientborders(d, c, selmon);
-    }
-    DEBUG("moveclientright: leaving\n");
-}
-
-// switch the current client with the first client we find above it
-void moveclientup(int *num, client *c, client **list, desktop *d) { 
-    DEBUG("moveclientup: entering\n");
-    client *cold; 
-    findtouchingclients[TTOP](d, c, list, num); // even if it not a direct match it should return with something touching
-    // switch stuff
-    if (list[0] != NULL) {
-        cold->xp = c->xp; cold->yp = c->yp; cold->wp = c->wp; cold->hp = c->hp;
-        adjustclientgaps(d->gap, list[0]);
-        c->xp = list[0]->xp; c->yp = list[0]->yp; c->wp = list[0]->wp; c->hp = list[0]->hp;
-        adjustclientgaps(d->gap, c);
-        list[0]->xp = cold->xp; list[0]->yp = cold->yp; list[0]->wp = cold->wp; list[0]->hp = cold->hp;
-        adjustclientgaps(d->gap, list[0]);
-        // move stuff
-        xcb_move_resize(dis, list[0]->win, 
-                        (list[0]->x = selmon->x + (selmon->w * list[0]->xp) + list[0]->gapx), 
-                        (list[0]->y = selmon->y + (selmon->h * list[0]->yp) + list[0]->gapy), 
-                        (list[0]->w = (selmon->w * list[0]->wp) - 2*BORDER_WIDTH - list[0]->gapx - list[0]->gapw), 
-                        (list[0]->h = (selmon->h * list[0]->hp) - 2*BORDER_WIDTH - list[0]->gapy - list[0]->gaph));
-        xcb_move_resize(dis, c->win, 
-                        (c->x = selmon->x + (selmon->w * c->xp) + c->gapx), 
-                        (c->y = selmon->y + (selmon->h * c->yp) + c->gapy), 
-                        (c->w = (selmon->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), 
-                        (c->h = (selmon->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph)); 
-        setclientborders(d, list[0], selmon);
-        setclientborders(d, c, selmon);
-    }
-    DEBUG("moveclientup: leaving\n");
-}
-
-void movefocus(const Arg *arg) {
-    desktop *d = &desktops[selmon->curr_dtop];
-    client *c = d->current, **list;
-
-    if((d->mode == TILE || d->mode == FLOAT) && !c->isfloating) { //capable of having windows to the right?
-        int n = d->count;
-        DEBUGP("movefocusdown: d->count = %d\n", d->count);
-        c = d->current;
-        list = (client**)malloc_safe(n * sizeof(client*)); 
-        findtouchingclients[arg->i](d, c, list, &n);
-        if (list[0] != NULL) focus(list[0], d, selmon);
-        free(list);
-    }
-}
-
-// cyclic focus the next window
-// if the window is the last on stack, focus head
-void next_win() {
-    desktop *d = &desktops[selmon->curr_dtop];
-    if (!d->current || !d->head->next) return;
-    focus(d->current->next ? d->current->next:d->head, d, selmon);
-}
-
-// cyclic focus the previous window
-// if the window is the head, focus the last stack window
-void prev_win() {
-    desktop *d = &desktops[selmon->curr_dtop];
-    if (!d->current || !d->head->next) return;
-    focus(prev_client(d->prevfocus = d->current, d), d, selmon);
-}
-
-void pulltofloat() {
-    DEBUG("pulltofloat: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    client *c = d->current;
-
-    if (!c->isfloating) {
-        c->isfloating = true;
-        d->count -= 1;
-        tileremove(c, d, selmon);
-    
-        // move it to the center of the screen
-        xcb_move_resize(dis, c->win, (c->x = selmon->w/2 - c->w/2), (c->y = selmon->h/2 - c->h/2), c->w, c->h);
-        xcb_raise_window(dis, c->win);
-    }
-    DEBUG("pulltofloat: leaving\n");
-}
-
-void pushtotiling() {
-    DEBUG("pushtotiling: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    int gap = d->gap;
-    client *c = NULL, *n = d->current; // the client to push
-    monitor *m = selmon;
-    
-    if (!n->isfloating && !n->istransient) // then it must already be tiled
-        return;
-
-    n->isfloating = false;
-    n->istransient = false;
- 
-    if (d->count == 0) { // no tiled clients
-        n->xp = 0; n->yp = 0; n->wp = 1; n->hp = 1;
-        adjustclientgaps(gap, n);
-        d->count += 1;
-        xcb_move_resize(dis, n->win, 
-                            (n->x = m->x + n->gapx), 
-                            (n->y = m->y + n->gapy), 
-                            (n->w = m->w - 2*n->gapw), 
-                            (n->h = m->h - 2*n->gaph));
-        setclientborders(d, n, selmon);
-        DEBUG("pushtotiling: leaving, tiled only client on desktop\n");
-        return;
-    } else if (d->prevfocus)
-        c = d->prevfocus;
-    if (c && c->isfloating) {
-        // try to find the first one behind the pointer
-        xcb_query_pointer_reply_t *pointer = xcb_query_pointer_reply(dis, xcb_query_pointer(dis, screen->root), 0);
-        if (!pointer) return;
-        int mx = pointer->root_x; int my = pointer->root_y;
-        for (c = d->head; c; c = c->next)
-            if(!ISFT(c) && INRECT(mx, my, c->x, c->y, c->w, c->h))
-                break;
-        // just find the first tiled client.
-        if (!c)
-            for (c = d->head; c; c = c->next)
-                if(!ISFT(c))
-                    break;
-    } 
+/* focus another desktop
+ *
+ * to avoid flickering
+ * first map the new windows
+ * first the current window and then all other
+ * then unmap the old windows
+ * first all others then the current */
+void change_desktop(const Arg *arg)
+{
+    if (arg->i == current_desktop)
+        return;
+    previous_desktop = current_desktop;
+    select_desktop(arg->i);
+    if (current && show)
+        xcb_map_window(dis, current->win);
+    for (client *c = head; c && show; c = c->next)
+        xcb_map_window(dis, c->win);
+    select_desktop(previous_desktop);
+    for (client *c = head; c; c = c->next)
+        if (c != current)
+            xcb_unmap_window(dis, c->win);
+    if (current)
+        xcb_unmap_window(dis, current->win);
+    select_desktop(arg->i);
+    tile();
+    update_current(current);
+    desktopinfo();
+    xcb_ewmh_set_current_desktop(ewmh, default_screen, arg->i);
 
-    if(!c) {
-        // TODO: get rid of this check
-        DEBUG("pushtotiling: leaving, error, !c\n");
-        return;
+    if (USE_SCRATCHPAD && scrpd && showscratchpad) {
+        xcb_map_window(dis, scrpd->win);
+        update_current(scrpd);
+        xcb_raise_window(dis, scrpd->win);
     }
-
-    tiledirection[d->direction](n, c); 
-        
-    d->count += 1;
-
-    adjustclientgaps(gap, c);
-    adjustclientgaps(gap, n);
-    
-    if (d->mode == TILE || d->mode == FLOAT) {
-        xcb_move_resize(dis, c->win,
-                        (c->x = m->x + (m->w * c->xp) + c->gapx), 
-                        (c->y = m->y + (m->h * c->yp) + c->gapy), 
-                        (c->w = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw),
-                        (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-        DEBUGP("pushtotiling: tiling current x:%f y:%f w:%f h:%f\n", (m->w * c->xp), (m->h * c->yp), (m->w * c->wp) , (m->h * c->hp));
-
-        xcb_move_resize(dis, n->win, 
-                        (n->x = m->x + (m->w * n->xp) + n->gapx), 
-                        (n->y = m->y + (m->h * n->yp) + n->gapy), 
-                        (n->w = (m->w * n->wp) - 2*BORDER_WIDTH - n->gapx - n->gapw), 
-                        (n->h = (m->h * n->hp) - 2*BORDER_WIDTH - n->gapy - n->gaph));
-        DEBUGP("pushtotiling: tiling new x:%f y:%f w:%f h:%f\n", (m->w * n->xp), (m->h * n->yp), (m->w * n->wp), (m->h * n->hp));
-    
-        setclientborders(d, c, selmon);
-        setclientborders(d, n, selmon);
-    } else 
-        monocle(m->x, m->y, m->w, m->h, d, m);
-    
-    DEBUG("pushtotiling: leaving\n");
-}
-
-// to quit just stop receiving events
-// run() is stopped and control is back to main()
-void quit(const Arg *arg) {
-    retval = arg->i;
-    running = false;
 }
 
-void resizeclient(const Arg *arg) {
-    DEBUG("resizeclient: entering\n"); 
-    desktop *d = &desktops[selmon->curr_dtop];
-    client *c, **list;
+/*
+ * place the current window in the center of the screen floating
+ */
+void centerwindow(void)
+{
+    xcb_get_geometry_reply_t *wa;
+    desktop *d = &desktops[current_desktop];
 
-    c = d->current;
-    if (!c) {
-        DEBUG("resizeclient: leaving, no d->current\n");
+    if (!d->current)
         return;
+
+    if (!d->current->isfloating && !d->current->istransient) {
+        float_client(d->current);
+        tile();
     }
-    monitor *m = wintomon(c->win);
 
-    int n = d->count;
-    DEBUGP("resizeclient: d->count = %d\n", d->count);
-    list = (client**)malloc_safe(n * sizeof(client*)); 
-
-    (arg->r)(d, arg->i, &n, arg->d, c, m, list);
-    free(list);
-    DEBUG("resizeclient: leaving\n");
-} 
-
-void resizeclientbottom(desktop *d, const int grow, int *n, const float size, client *c, monitor *m, client **list) {
-    DEBUG("resizeclientbottom: entering\n"); 
-    if (findtouchingclients[TBOTTOM](d, c, list, n)) {
-        if (grow) {
-            //client in list y increases and height decreases
-            for (int i = 0; i < (*n); i++)
-                shrinkbyy(NULL, size, list[i], m, d);
-            //current windows height increases
-            growbyh(list[0], size, c, m, d);
-        } else {
-            shrinkbyh(NULL, size, c, m, d);
-            for (int i = 0; i < (*n); i++)
-                growbyy(c, size, list[i], m, d);
-        }
-    } else if (findtouchingclients[TTOP](d, c, list, n)) {
-        if (grow) {
-            //current windows y increases and height decreases
-            shrinkbyy(NULL, size, c, m, d);
-            //client in list height increases
-            for (int i = 0; i < (*n); i++)
-                growbyh(c, size, list[i], m, d);
-        } else {
-            for (int i = 0; i < (*n); i++)
-                shrinkbyh(NULL, size, list[i], m, d);
-            growbyy(list[0], size, c, m, d);
-        }
-    }
-    DEBUG("resizeclientbottom: leaving\n");
-}
-
-void resizeclientleft(desktop *d, const int grow, int *n, const float size, client *c, monitor *m, client **list) {
-    DEBUG("resizeclientleft: entering\n"); 
-    if (findtouchingclients[TLEFT](d, c, list, n)) {
-        if (grow) {
-            //client in list width decreases
-            for (int i = 0; i < (*n); i++)
-                shrinkbyw(NULL, size, list[i], m, d);
-            //the current windows x decreases and width increases
-            growbyx(list[0], size, c, m, d);
-        } else {
-            shrinkbyx(NULL, size, c, m, d);
-            for (int i = 0; i < (*n); i++)
-                growbyw(c, size, list[i], m, d);
-        }
-    } else if (findtouchingclients[TRIGHT](d, c, list, n)) {
-        if (grow) {
-            //current windows width decreases
-            shrinkbyw(NULL, size, c, m, d);
-            //clients in list x decreases width increases
-            for (int i = 0; i < (*n); i++)
-                growbyx(c, size, list[i], m, d);
-        } else { 
-            for (int i = 0; i < (*n); i++)
-                shrinkbyx(NULL, size, list[i], m, d);
-            growbyw(list[0], size, c, m, d);
-        }
-    }
-    DEBUG("resizeclientleft: leaving\n");
-}
-
-void resizeclientright(desktop *d, const int grow, int *n, const float size, client *c, monitor *m, client **list) {
-    DEBUG("resizeclientright: entering\n");
-    if (findtouchingclients[TRIGHT](d, c, list, n)) { 
-        if (grow) {
-            //clients in list x increases and width decrease
-            for (int i = 0; i < (*n); i++)
-                shrinkbyx(NULL, size, list[i], m, d);
-            //the current windows width increases
-            growbyw(list[0], size, c, m, d);
-        } else {
-            shrinkbyw(NULL, size, c, m, d);
-            for (int i = 0; i < (*n); i++)
-                growbyx(c, size, list[i], m, d);
-        }
-    } else if (findtouchingclients[TLEFT](d, c, list, n)) {
-        if (grow) {
-            //current windows x increases and width decreases
-            shrinkbyx(NULL, size, c, m, d);
-            //other windows width increases
-            for (int i = 0; i < (*n); i++)
-                growbyw(c, size, list[i], m, d);
-        } else {
-            for (int i = 0; i < (*n); i++)
-                shrinkbyw(NULL, size, list[i], m, d);
-            growbyx(list[0], size, c, m, d);
-        }
-    }
-    DEBUG("resizeclientright: leaving\n");
-}
-
-void resizeclienttop(desktop *d, const int grow, int *n, const float size, client *c, monitor *m, client **list) {
-    DEBUG("resizeclienttop: entering\n"); 
-    if (findtouchingclients[TTOP](d, c, list, n)) {
-        if (grow) {
-            //client in list height decreases
-            for (int i = 0; i < (*n); i++)
-                shrinkbyh(NULL, size, list[i], m, d);
-            //current windows y decreases and height increases
-            growbyy(list[0], size, c, m, d);
-        } else {
-            shrinkbyy(NULL, size, c, m, d);
-            for (int i = 0; i < (*n); i++)
-                growbyh(c, size, list[i], m, d);
-        }
-    } else if (findtouchingclients[TBOTTOM](d, c, list, n)) {
-        if (grow) {
-            //current windows height decreases
-            shrinkbyh(NULL, size, c, m, d);
-            //client in list y decreases and height increases
-            for (int i = 0; i < (*n); i++)
-               growbyy(c, size, list[i], m, d);
-        }else { 
-            for (int i = 0; i < (*n); i++)
-                shrinkbyy(NULL, size, list[i], m, d);
-            growbyh(list[0], size, c, m, d);
-        }
-    } 
-    DEBUG("resizeclienttop: leaving\n");
-}
-
-// jump and focus the next or previous desktop
-void rotate(const Arg *arg) {
-    change_desktop(&(Arg){.i = (DESKTOPS + selmon->curr_dtop + arg->i) % DESKTOPS});
-}
+    wa = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win), NULL);
+    if (!wa)
+        /* TODO this is not particularly nice if we fail */
+        return;
 
-// jump and focus the next or previous desktop that has clients
-void rotate_filled(const Arg *arg) {
-    int n = arg->i;
-    while (n < DESKTOPS && !desktops[(DESKTOPS + selmon->curr_dtop + n) % DESKTOPS].head) (n += arg->i);
-    change_desktop(&(Arg){.i = (DESKTOPS + selmon->curr_dtop + n) % DESKTOPS});
+    xcb_raise_window(dis, d->current->win);
+    xcb_move(dis, d->current->win, (ww - wa->width) / 2, (wh - wa->height) / 2);
+    free(wa);
 }
 
-// execute a command
-void spawn(const Arg *arg) {
-    if (fork()) return;
-    if (dis) close(screen->root);
-    setsid();
-    execvp((char*)arg->com[0], (char**)arg->com);
-    fprintf(stderr, "error: execvp %s", (char *)arg->com[0]);
-    perror(" failed"); // also prints the err msg
-    exit(EXIT_SUCCESS);
-}
+/* remove all windows in all desktops by sending a delete message */
+void cleanup(void)
+{
+    xcb_query_tree_reply_t *query;
+    xcb_window_t *c;
 
-// switch the tiling direction
-void switch_direction(const Arg *arg) {
-    desktop *d = &desktops[selmon->curr_dtop];
-    if (d->mode != TILE) {
-        d->mode = TILE;
-        retile(d, selmon);
-    }
-    if (d->direction != arg->i) d->direction = arg->i;
-    #if PRETTY_PRINT
-    updatemode();
-    updatedir();
-    desktopinfo();
-    #endif
-}
+    xcb_ungrab_key(dis, XCB_GRAB_ANY, screen->root, XCB_MOD_MASK_ANY);
+    if ((query = xcb_query_tree_reply(dis,
+                                      xcb_query_tree(dis, screen->root), 0))) {
+        c = xcb_query_tree_children(query);
+        for (unsigned int i = 0; i != query->children_len; ++i)
+            deletewindow(c[i]);
+        free(query);
+    }
+    xcb_set_input_focus(dis, XCB_INPUT_FOCUS_POINTER_ROOT, screen->root,
+                        XCB_CURRENT_TIME);
+    xcb_ewmh_connection_wipe(ewmh);
+    if (ewmh)
+        free(ewmh);
 
-// switch the tiling mode or to floating mode,
-void switch_mode(const Arg *arg) {
-    desktop *d = &desktops[selmon->curr_dtop];
-    if (d->mode != arg->i) d->mode = arg->i;
-    retile(d, selmon); // we need to retile when switching from video/monocle to tile/float
-    #if PRETTY_PRINT
-    updatemode();
-    desktopinfo();
-    #endif
-}
+    for (unsigned int i = 0; i < LENGTH(rules); i++)
+        regfree(&appruleregex[i]);
 
-// toggle visibility state of the panel
-void togglepanel() {
-    desktop *d = &desktops[selmon->curr_dtop];
-    d->showpanel = !d->showpanel;
-    retile(d, selmon);
-}
-
-// UTILITIES 
-
-static monitor* ptrtomon(int x, int y) {
-    monitor *m;
-    int i;
-
-    for(i = 0, m = mons; i < nmons; m = m->next, i++)
-        if(INRECT(x, y, m->x, m->y, m->w, m->h))
-            return m;
-    return selmon;
-}
-
-void adjustclientgaps(const int gap, client *c) {
-        if (c->xp == 0) c->gapx = gap;
-        else c->gapx = gap/2;
-        if (c->yp == 0) c->gapy = gap;
-        else c->gapy = gap/2;
-        if ((c->xp + c->wp) > 0.99999) c->gapw = gap;
-        else c->gapw = gap/2;
-        if ((c->yp + c->hp) > 0.99999) c->gaph = gap;
-        else c->gaph = gap/2;
-}
-
-bool clientstouchingbottom(desktop *d, client *c, client **list, int *num) {
-    DEBUG("clientstouchingbottom: entering\n");
-    if((c->yp + c->hp) < 1) { //capable of having windows below?
-        float width;
-        (*num) = 0;
-        width = c->wp;
-        for (client *n = d->head; n; n = n->next) {
-            if ((c != n ) && !ISFT(n) && (n->yp == (c->yp + c->hp))) { // directly below
-                if ((n->xp + n->wp) <= (c->xp + c->wp)) { // width equivalent or less than
-                    if ((n->xp == c->xp) && (n->wp == c->wp)) { //direct match?
-                        DEBUG("clientstouchingbottom: found direct match\n");
-                        list[(*num)] = n;
-                        (*num)++;
-                        DEBUG("clientstouchingbottom: leaving, found direct match\n");
-                        return true;
-                    }
-                    else if (n->xp >= c->xp) { // part
-                        width -= n->wp;
-                        list[(*num)] = n;
-                        (*num)++;
-                        if (width < 0.00001) {
-                            DEBUG("clientstouchingbottom: leaving true\n");
-                            return true;
-                        }
-                        if (width < 0) {
-                            DEBUG("clientstouchingbottom: leaving false\n");
-                            return false;
-                        }
-                    }
-                }
-                
-                if ((n->xp <= c->xp) && ((n->xp + n->wp) >= (c->xp + c->wp))) { 
-                    // width exceeds, but we should go ahead and make sure list isnt NULL
-                    list[(*num)] = n;
-                    DEBUG("clientstouchingbottom: leaving false\n");
-                    return false;
-                }
-            }
+    for (unsigned int i = 0; i < DESKTOPS; i++) {
+        for (struct filo *tmp = miniq[i], *tmp_next; tmp; tmp = tmp_next) {
+            tmp_next = tmp->next;
+            free(tmp);
         }
-    }
-    DEBUG("clientstouchingbottom: leaving error\n");
-    return false;
-}
 
-bool clientstouchingleft(desktop *d, client *c, client **list, int *num) {
-    DEBUG("clientstouchingleft: entering\n");
-    if(c->xp > 0) { // capable of having windows to the left?
-        float height;
-        (*num) = 0;
-        height = c->hp;
-        for (client *n = d->head; n; n = n->next) {
-            DEBUGP("clientstouchingleft: %f == %f\n", c->xp, n->xp + n->wp);
-            if ((c != n ) && !ISFT(n) && (c->xp == (n->xp + n->wp))) { // directly to the left
-                DEBUGP("clientstouchingleft: %f <= %f\n",n->yp + n->hp, c->yp + c->hp);
-                if ((n->yp + n->hp) <= (c->yp + c->hp)) { // height equivalent or less than
-                    if ((n->yp == c->yp) && (n->hp == c->hp)) { // direct match?
-                        list[(*num)] = n;
-                        (*num)++;
-                        DEBUG("clientstouchingleft: leaving found direct match\n");
-                        return true;
-                    }
-                    else if (n->yp >= c->yp) { // part
-                        height -= n->hp;
-                        list[(*num)] = n;
-                        (*num)++;
-                        DEBUGP("clientstouchingleft: height = %f\n", height);
-                        if (height < 0.00001) {
-                            DEBUG("clientstouchingleft: leaving true\n");
-                            return true;
-                        }
-                        if (height < 0) {
-                            DEBUG("clientstouchingleft: leaving false\n");
-                            return false;
-                        }
-                    }
-                }
-                
-                if ((n->yp <= c->yp) && ((n->yp + n->hp) >= (c->yp + c->hp))) { 
-                    // height exceeds, but we should go ahead and make sure list isnt NULL
-                    list[(*num)] = n;
-                    DEBUG("clientstouchingleft: leaving false\n");
-                    return false;
-                }
-            }
+        for (client *c = desktops[i].head, *c_next; c; c = c_next) {
+            c_next = c->next;
+            free(c);
         }
     }
-    DEBUG("clientstouchingleft: leaving error\n");
-    return false;
 }
 
-bool clientstouchingright(desktop *d, client *c, client **list, int *num) {
-    DEBUG("clientstouchingright: entering\n");
-    if((c->xp + c->wp) < 1) { // capable of having windows to the right?
-        float height;
-        (*num) = 0;
-        height = c->hp;
-        for (client *n = d->head; n; n = n->next) {
-            if ((c != n ) && !ISFT(n) && (n->xp == (c->xp + c->wp))) { // directly to the right
-                if ((n->yp + n->hp) <= (c->yp + c->hp)) { // height equivalent or less than
-                    if ((n->yp == c->yp) && (n->hp == c->hp)) { // direct match?
-                        list[(*num)] = n;
-                        (*num)++;
-                        DEBUG("clientstouchingright: leaving, found direct match\n");
-                        return true;
-                    }
-                    else if (n->yp >= c->yp) { // part
-                        height -= n->hp;
-                        list[(*num)] = n;
-                        (*num)++;
-                        if (height < 0.00001) {
-                            DEBUG("clientstouchingright: leaving true\n");
-                            return true;
-                        }
-                        if (height < 0) {
-                            DEBUG("clientstouchingright: leaving false\n");
-                            return false;
-                        }
-                    }
-                }
-                // y is less than or equal, overall height 
-                if ((n->yp <= c->yp) && ((n->yp + n->hp) >= (c->yp + c->hp))) { 
-                    // height exceeds, but we should go ahead and make sure list isnt NULL
-                    list[(*num)] = n;
-                    DEBUG("clientstouchingright: leaving false\n");
-                    return false;
-                }
-            }
-        }
-    }
-    DEBUG("clientstouchingright: leaving error\n");
-    return false;
+/* move a client to another desktop
+ *
+ * remove the current client from the current desktop's client list
+ * and add it as last client of the new desktop's client list */
+void client_to_desktop(const Arg *arg)
+{
+    if (!current || arg->i == current_desktop)
+        return;
+    int cd = current_desktop;
+    client *p = prev_client(current), *c = current;
+
+    select_desktop(arg->i);
+    client *l = prev_client(head);
+    update_current(l ? (l->next = c) : head ? (head->next = c) : (head = c));
+
+    select_desktop(cd);
+    if (c == head || !p)
+        head = c->next;
+    else
+        p->next = c->next;
+    c->next = NULL;
+    xcb_unmap_window(dis, c->win);
+    update_current(prevfocus);
+
+    if (FOLLOW_WINDOW)
+        change_desktop(arg);
+    else
+        tile();
+    desktopinfo();
 }
 
-bool clientstouchingtop(desktop *d, client *c, client **list, int *num) {
-    DEBUG("clientstouchingtop: entering\n");
-    if(c->yp > 0) { //capable of having windows above?
-        float width;
-        (*num) = 0;
-        width = c->wp;
-        for (client *n = d->head; n; n = n->next) {
-            if ((c != n) && !ISFT(n) && (c->yp == (n->yp + n->hp))) {// directly above
-                if ((n->xp + n->wp) <= (c->xp + c->wp)) { //width equivalent or less than
-                    if ((n->xp == c->xp) && (n->wp == c->wp)) { //direct match?
-                        list[(*num)] = n;
-                        (*num)++;
-                        DEBUG("clientstouchingtop: leaving found direct match\n");
-                        return true;
-                    }
-                    else if (n->xp >= c->xp) { //part
-                        width -= n->wp;
-                        list[(*num)] = n;
-                        (*num)++;
-                        if (width < 0.00001) {
-                            DEBUG("clientstouchingtop: leaving true\n");
-                            return true;
-                        }
-                        if (width < 0) {
-                            DEBUG("clientstouchingtop: leaving false\n");
-                            return false;
-                        }
-                    }
-                }
-                
-                if ((n->xp <= c->xp) && ((n->xp + n->wp) >= (c->xp + c->wp))) { 
-                    // width exceeds, but we should go ahead and make sure list isnt NULL
-                    list[(*num)] = n;
-                    DEBUG("clientstouchingtop: leaving false\n");
-                    return false;
-                }
-            }
-        }
+/*
+ * Here we take and process client messages. Currently supported messages are:
+ * _NET_WM_STATE
+ * _NET_CURRENT_DESKTOP
+ * _NET_ACTIVE_WINDOW
+ * _NET_CLOSE_WINDOW
+ *
+ * data.data32[0] is the action to be taken
+ * data.data32[1] is the property to alter three actions:
+ *   remove/unset _NET_WM_STATE_REMOVE=0
+ *   add/set _NET_WM_STATE_ADD=1
+ *   toggle _NET_WM_STATE_TOGGLE=2
+ */
+void clientmessage(xcb_generic_event_t *e)
+{
+    xcb_client_message_event_t *ev = (xcb_client_message_event_t *)e;
+    client *t = NULL, *c = wintoclient(ev->window);
+
+    if (c && ev->type == netatoms[NET_WM_STATE]
+          && ((unsigned)ev->data.data32[1] == netatoms[NET_FULLSCREEN]
+           || (unsigned)ev->data.data32[2] == netatoms[NET_FULLSCREEN]))
+        setfullscreen(c, (ev->data.data32[0] == 1 ||
+                         (ev->data.data32[0] == 2 &&
+                         !c->isfullscrn)));
+    else if (c && ev->type == netatoms[NET_CURRENT_DESKTOP]
+             && ev->data.data32[0] < DESKTOPS)
+        change_desktop(&(Arg){.i = ev->data.data32[0]});
+    else if (c && ev->type == netatoms[NET_CLOSE_WINDOW])
+        removeclient(c);
+    else if (c && ev->type == netatoms[NET_ACTIVE])
+        for (t = head; t && t != c; t = t->next);
+    if (t)
+        update_current(c);
+    tile();
+}
+
+/* a configure request means that the window requested changes in its geometry
+ * state. if the window is fullscreen discard and fill the screen else set the
+ * appropriate values as requested, and tile the window again so that it fills
+ * the gaps that otherwise could have been created
+ */
+void configurerequest(xcb_generic_event_t *e)
+{
+    xcb_configure_request_event_t *ev = (xcb_configure_request_event_t *)e;
+    client *c = wintoclient(ev->window);
+
+    if (c && c->isfullscrn) {
+        setfullscreen(c, true);
+    } else {
+        unsigned int v[7];
+        unsigned int i = 0;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_X)
+            v[i++] = ev->x;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_Y)
+            v[i++] = (ev->y + (showpanel && TOP_PANEL)) ? PANEL_HEIGHT : 0;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_WIDTH)
+            v[i++] = (ev->width < ww - borders) ? ev->width : ww + borders;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_HEIGHT)
+            v[i++] = (ev->height < wh - borders) ? ev->height : wh + borders;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_BORDER_WIDTH)
+            v[i++] = ev->border_width;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_SIBLING)
+            v[i++] = ev->sibling;
+        if (ev->value_mask & XCB_CONFIG_WINDOW_STACK_MODE)
+            v[i++] = ev->stack_mode;
+        xcb_configure_window(dis, ev->window, ev->value_mask, v);
     }
-    DEBUG("clientstouchingtop: leaving error\n");
-    return false;
+    tile();
 }
 
+/* close the window */
+void deletewindow(xcb_window_t w)
+{
+    xcb_client_message_event_t ev = {0};
 
-// close the window
-void deletewindow(xcb_window_t w) {
-    DEBUG("deletewindow: entering\n");
-    xcb_client_message_event_t ev;
     ev.response_type = XCB_CLIENT_MESSAGE;
     ev.window = w;
     ev.format = 32;
@@ -1219,1635 +716,1326 @@ void deletewindow(xcb_window_t w) {
     ev.type = wmatoms[WM_PROTOCOLS];
     ev.data.data32[0] = wmatoms[WM_DELETE_WINDOW];
     ev.data.data32[1] = XCB_CURRENT_TIME;
-    xcb_send_event(dis, 0, w, XCB_EVENT_MASK_NO_EVENT, (char*)&ev);
-    DEBUG("deletewindow: leaving\n");
+    xcb_send_event(dis, 0, w, XCB_EVENT_MASK_NO_EVENT, (char *)&ev);
 }
 
-#if PRETTY_PRINT
-// output info about the desktops on standard output stream
-// once the info is printed, immediately flush the stream
-void desktopinfo(void) {
-    DEBUG("desktopinfo: entering\n"); 
-    desktop *d = &desktops[selmon->curr_dtop];
-    PP_PRINTF;
+/*
+ * output info about the desktops on standard output stream
+ *
+ * the info is a list of ':' separated values for each desktop
+ * desktop to desktop info is separated by ' ' single spaces
+ * the info values are
+ *   the desktop number/id
+ *   the desktop's client count
+ *   the desktop's tiling layout mode/id
+ *   whether the desktop is the current focused (1) or not (0)
+ *   whether any client in that desktop has received an urgent hint
+ *   and the current window's title
+ *
+ * once the info is collected, immediately flush the stream
+ */
+void desktopinfo(void)
+{
+    bool urgent = false;
+    int cd = current_desktop, n = 0, d = 0;
+    xcb_get_property_cookie_t cookie;
+    xcb_ewmh_get_utf8_strings_reply_t wtitle;
+    wtitle.strings = NULL;
+
+    if (current) {
+        cookie = xcb_ewmh_get_wm_name_unchecked(ewmh, current->win);
+        xcb_ewmh_get_wm_name_reply(ewmh, cookie, &wtitle, (void *)0);
+    }
+
+    for (client *c; d < DESKTOPS; d++) {
+        for (select_desktop(d), c = head, n = 0, urgent = false;
+             c; c = c->next, ++n)
+            if (c->isurgent)
+                urgent = true;
+        fprintf(stdout, "%d:%d:%d:%d:%d ", d, n, mode, current_desktop == cd,
+                urgent);
+        if (d + 1 == DESKTOPS)
+            fprintf(stdout, "%s\n", current && OUTPUT_TITLE && wtitle.strings ?
+                    wtitle.strings : "");
+    }
+
+    if (wtitle.strings) {
+        xcb_ewmh_get_utf8_strings_reply_wipe(&wtitle);
+    }
+
     fflush(stdout);
-    DEBUG("desktopinfo: leaving\n");
+    if (cd != d - 1)
+        select_desktop(cd);
 }
-#endif
 
-// highlight borders and set active window and input focus
-// if given current is NULL then delete the active window property
-//
-// stack order by client properties, top to bottom:
-//  - current when floating or transient
-//  - floating or trancient windows
-//  - current when tiled
-//  - current when fullscreen
-//  - fullscreen windows
-//  - tiled windows
-//
-// a window should have borders in any case, except if
-//  - the window is the only window on screen
-//  - the mode is MONOCLE or VIDEO
-void focus(client *c, desktop *d, const monitor *m) {
-    DEBUG("focus: entering\n"); 
-    
-    if (!c) {
-        xcb_delete_property(dis, screen->root, netatoms[NET_ACTIVE]);
-        d->current = d->prevfocus = NULL;
-        return;
-    }  
-    if (c == d->prevfocus && d->current != c->next) { 
-        d->prevfocus = prev_client(d->current = c, d);
-    } else if (c != d->current) { 
-        d->prevfocus = d->current; 
-        d->current = c; 
-    }
-    setdesktopborders(d, m);
-    //#if CLICK_TO_FOCUS 
-    //xcb_grab_button(dis, 1, c->win, XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC,
-    //                    XCB_WINDOW_NONE, XCB_NONE, XCB_BUTTON_INDEX_1, XCB_BUTTON_MASK_ANY);
-    //#endif
+/*
+ * a destroy notification is received when a window is being closed
+ * on receival, remove the appropriate client that held that window
+ */
+void destroynotify(xcb_generic_event_t *e)
+{
+    DEBUG("xcb: destroy notify");
+    xcb_destroy_notify_event_t *ev = (xcb_destroy_notify_event_t *)e;
+    client *c = wintoclient(ev->window);
 
-    xcb_change_property(dis, XCB_PROP_MODE_REPLACE, screen->root, netatoms[NET_ACTIVE], XCB_ATOM_WINDOW, 32, 1, &c->win);
-    xcb_set_input_focus(dis, XCB_INPUT_FOCUS_POINTER_ROOT, c->win, XCB_CURRENT_TIME);
-    xcb_flush(dis);
-     
-    #if PRETTY_PRINT
+    if (c) {
+        removeclient(c);
+    } else if (USE_SCRATCHPAD && scrpd && ev->window == scrpd->win) {
+        free(scrpd);
+        scrpd = NULL;
+        update_current(head);
+    }
     desktopinfo();
-    #endif
-    DEBUG("focus: leaving\n");
 }
 
-bool getrootptr(int *x, int *y) {
-    xcb_query_pointer_reply_t *reply = xcb_query_pointer_reply(dis, xcb_query_pointer(dis, screen->root), NULL);
+/* dualstack layout (three-column-layout, tcl in dwm) */
+void dualstack(int hh, int cy)
+{
+    client *c = NULL, *t = NULL;
+    int n = 0, z = hh, d = 0, l = 0, r = 0, cb = cy,
+        ma = (invert ? wh : ww) * MASTER_SIZE + master_size;
+
+    /* count stack windows and grab first non-floating, non-fullscreen window */
+    for (t = head; t; t = t->next) {
+        if (!ISFFTM(t)) {
+            if (c)
+                ++n;
+            else
+                c = t;
+        }
+    }
 
-    *x = reply->root_x;
-    *y = reply->root_y;
+    l = (n - 1) / 2 + 1; /* left stack size */
+    r = n - l;          /* right stack size */
 
-    free(reply);
+    if (!c) {
+        return;
+    } else if (!n) {
+        xcb_move_resize(dis, c->win, gaps, cy + gaps,
+                        ww - 2 * (borders + gaps),
+                        hh - 2 * (borders + gaps));
+        return;
+    }
 
-    return true;
+    /* tile the first non-floating, non-fullscreen window to cover the master area */
+    if (invert)
+        xcb_move_resize(dis, c->win, gaps,
+                        cy + (hh - ma) / 2 + gaps,
+                        ww - 2 * (borders + gaps),
+                        n > 1 ? ma - 2 * gaps - 2 * borders
+                              : ma + (hh - ma) / 2 - 2 * borders - 2 * gaps);
+    else
+        xcb_move_resize(dis, c->win, (ww - ma) / 2 + borders + gaps,
+                        cy + gaps,
+                        n > 1 ? ma - 4 * borders - 2 * gaps
+                              : ma + (ww - ma) / 2 - 3 * borders - 2 * gaps,
+                        hh - 2 * (borders + gaps));
+
+    int cx = gaps,
+        cw = (ww - ma) / 2 - borders - gaps,
+        ch = z;
+        cy += gaps;
+
+    /* tile the non-floating, non-fullscreen stack windows */
+    for (c = c->next; c; c = c->next) {
+        for (d = 0, t = head; t != c; t = t->next, d++);
+        if (ISFFTM(c))
+            continue;
+        if (invert) {
+            if (d == l + 1) /* we are on the -right- bottom stack, reset cy */
+                cx = gaps;
+            if (d > 1 && d != l + 1)
+                cx += (ww - gaps) / (d <= l ? l : r);
+            xcb_move_resize(dis, c->win,
+                        cx, (d <= l) ? cy : cy + (hh - ma) / 2 + ma - gaps,
+                        (ww - gaps) / (d <= l ? l : r) - 2 * borders - gaps,
+                        (hh - ma) / 2 - 2 * borders - gaps);
+        } else {
+            if (d == l + 1) /* we are on the right stack, reset cy */
+                cy = cb + gaps;
+            if (d > 1 && d != l + 1)
+                cy += (ch - gaps) / (d <= l ? l : r);
+            xcb_move_resize(dis, c->win,
+                        d <= l ? cx : ww - cw - 2 * borders - gaps, cy, cw,
+                        (ch - gaps) / (d <= l ? l : r) - 2 * borders - gaps);
+        }
+    }
 }
 
-// set the given client to listen to button events (presses / releases)
-void grabbuttons(client *c) {
-    DEBUG("grabbuttons: entering\n");
-    unsigned int i, j, modifiers[] = { 0, XCB_MOD_MASK_LOCK, numlockmask, numlockmask|XCB_MOD_MASK_LOCK }; 
-    xcb_ungrab_button(dis, XCB_BUTTON_INDEX_ANY, c->win, XCB_GRAB_ANY);
-    for(i = 0; i < LENGTH(buttons); i++)
-        for(j = 0; j < LENGTH(modifiers); j++)
-            #if CLICK_TO_FOCUS
-            xcb_grab_button(dis, false, c->win, BUTTONMASK, XCB_GRAB_MODE_SYNC,
-                                XCB_GRAB_MODE_ASYNC, XCB_WINDOW_NONE, XCB_CURSOR_NONE,
-                                XCB_BUTTON_INDEX_ANY, XCB_BUTTON_MASK_ANY);
-    
-            #else
-            xcb_grab_button(dis, false, c->win, BUTTONMASK, XCB_GRAB_MODE_SYNC,
-                                XCB_GRAB_MODE_ASYNC, XCB_WINDOW_NONE, XCB_CURSOR_NONE,
-                                buttons[i].button, buttons[i].mask | modifiers[j]);
-            #endif
-    DEBUG("grabbuttons: leaving\n");
-}
+/*
+ * when the mouse enters a window's borders
+ * the window, if notifying of such events (EnterWindowMask)
+ * will notify the wm and will get focus
+ */
+void enternotify(xcb_generic_event_t *e)
+{
+    xcb_enter_notify_event_t *ev = (xcb_enter_notify_event_t *)e;
 
-// the wm should listen to key presses
-void grabkeys(void) {
-    xcb_keycode_t *keycode;
-    unsigned int modifiers[] = { 0, XCB_MOD_MASK_LOCK, numlockmask, numlockmask|XCB_MOD_MASK_LOCK };
-    xcb_ungrab_key(dis, XCB_GRAB_ANY, screen->root, XCB_MOD_MASK_ANY);
-    for (unsigned int i=0; i<LENGTH(keys); i++) {
-        keycode = xcb_get_keycodes(keys[i].keysym);
-        for (unsigned int k=0; keycode[k] != XCB_NO_SYMBOL; k++)
-            for (unsigned int m=0; m<LENGTH(modifiers); m++)
-                xcb_grab_key(dis, 1, screen->root, keys[i].mod | modifiers[m], keycode[k], XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC);
-    }
-}
+    if (!FOLLOW_MOUSE)
+        return;
+    DEBUG("xcb: enter notify");
+    client *c = wintoclient(ev->event);
 
-void* malloc_safe(size_t size) {
-    void *ret;
-    if(!(ret = malloc(size)))
-        puts("malloc_safe: fatal: could not malloc()");
-    memset(ret, 0, size);
-    return ret;
+    if (c && ev->mode == XCB_NOTIFY_MODE_NORMAL
+        && current != c
+        && ev->detail != XCB_NOTIFY_DETAIL_INFERIOR) {
+        update_current(c);
+    }
 }
 
-// get the previous client from the given
-// if no such client, return NULL
-client* prev_client(client *c, desktop *d) {
-    if (!c || !d->head->next)
-        return NULL;
-    client *p;
-    for (p = d->head; p->next && p->next != c; p = p->next);
-    return p;
-}
+/*
+ * equal mode
+ * tile the windows in rows or columns, givin each window an equal amount of
+ * screen space
+ * will use rows when inverted and columns otherwise
+ */
+void equal(int h, int y)
+{
+    int n = 0, j = -1;
 
-void setclientborders(desktop *d, client *c, const monitor *m) {
-    DEBUG("setclientborders: entering\n"); 
-    unsigned int values[1];  /* this is the color maintainer */
-    unsigned int zero[1];
-    int half;
-    
-    zero[0] = 0;
-    values[0] = BORDER_WIDTH; // Set border width.
-
-    // find n = number of windows with set borders
-    int n = d->count;
-    DEBUGP("setclientborders: d->count = %d\n", d->count);
-
-    // rules for no border
-    if ((!c->isfloating && n == 1) || (d->mode == MONOCLE) || (d->mode == VIDEO)) {
-        xcb_configure_window(dis, c->win, XCB_CONFIG_WINDOW_BORDER_WIDTH, zero);
-    }
-    else {
-        xcb_configure_window(dis, c->win, XCB_CONFIG_WINDOW_BORDER_WIDTH, values);
-        half = OUTER_BORDER;
-        const xcb_rectangle_t rect_inner[] = {
-            { c->w,0, BORDER_WIDTH-half,c->h+BORDER_WIDTH-half},
-            { c->w+BORDER_WIDTH+half,0, BORDER_WIDTH-half,c->h+BORDER_WIDTH-half},
-            { 0,c->h,c->w+BORDER_WIDTH-half,BORDER_WIDTH-half},
-            { 0, c->h+BORDER_WIDTH+half,c->w+BORDER_WIDTH-half,BORDER_WIDTH-half},
-            { c->w+BORDER_WIDTH+half,BORDER_WIDTH+c->h+half,BORDER_WIDTH,BORDER_WIDTH }
-        };
-        const xcb_rectangle_t rect_outer[] = {
-            {c->w+BORDER_WIDTH-half,0,half,c->h+BORDER_WIDTH*2},
-            {c->w+BORDER_WIDTH,0,half,c->h+BORDER_WIDTH*2},
-            {0,c->h+BORDER_WIDTH-half,c->w+BORDER_WIDTH*2,half},
-            {0,c->h+BORDER_WIDTH,c->w+BORDER_WIDTH*2,half}
-        };
-        xcb_pixmap_t pmap = xcb_generate_id(dis);
-        // 2bwm test have shown that drawing the pixmap directly on the root 
-        // window is faster then drawing it on the window directly
-        xcb_create_pixmap(dis, screen->root_depth, pmap, c->win, c->w+(BORDER_WIDTH*2), c->h+(BORDER_WIDTH*2));
-        xcb_gcontext_t gc = xcb_generate_id(dis);
-        xcb_create_gc(dis, gc, pmap, 0, NULL);
-        
-        xcb_change_gc(dis, gc, XCB_GC_FOREGROUND, 
-                        (c->isurgent ? &win_urgent:c->istransient ? &win_trn:c->isfloating ? &win_flt:&win_outer));
-        xcb_poly_fill_rectangle(dis, pmap, gc, 4, rect_outer);
-
-        xcb_change_gc(dis, gc, XCB_GC_FOREGROUND, (c == d->current && m == selmon ? &win_focus:&win_unfocus));
-        xcb_poly_fill_rectangle(dis, pmap, gc, 5, rect_inner);
-        xcb_change_window_attributes(dis,c->win, XCB_CW_BORDER_PIXMAP, &pmap);
-        // free the memory we allocated for the pixmap
-        xcb_free_pixmap(dis,pmap);
-        xcb_free_gc(dis,gc);
+    for (client *c = head; c; c = c->next) {
+        if (ISFFTM(c))
+            continue;
+        n++;
     }
-    xcb_flush(dis);
-    DEBUG("setclientborders: leaving\n");
-}
 
-void setdesktopborders(desktop *d, const monitor *m) {
-    DEBUG("setdesktopborders: entering\n");  
-    client *c = NULL;
-    for (c = d->head; c; c = c -> next)
-        setclientborders(d, c, m);
-    DEBUG("setdesktopborders: leaving\n");
-}
-
-#if PRETTY_PRINT
-void updatedir() {
-    DEBUG("updatedir: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    char *tags_dir[] = PP_TAGS_DIR;
-    char temp[512];
-     
-    if (tags_dir[d->direction]) {
-        snprintf(temp, 512, "^fg(%s)%s ", PP_COL_DIR, tags_dir[d->direction]);
-        pp.dir = realloc(pp.dir, strlen(temp));
-        sprintf(pp.dir, "^fg(%s)%s ", PP_COL_DIR, tags_dir[d->direction]);
-    } else {
-        snprintf(temp, 512, "^fg(%s)%d ", PP_COL_DIR, d->direction);
-        pp.dir = realloc(pp.dir, strlen(temp));
-        sprintf(pp.dir, "^fg(%s)%d ", PP_COL_DIR, d->direction);
-    }
-    DEBUG("updatedir: leaving\n");
-}
-
-void updatemode() {
-    DEBUG("updatemode: entering\n");
-    desktop *d = &desktops[selmon->curr_dtop];
-    char *tags_mode[] = PP_TAGS_MODE;
-    char temp[512];
-    
-    if (tags_mode[d->mode]) {
-        snprintf(temp, 512, "^fg(%s)%s ", PP_COL_MODE, tags_mode[d->mode]);
-        pp.mode = realloc(pp.mode, strlen(temp));
-        sprintf(pp.mode, "^fg(%s)%s ", PP_COL_MODE, tags_mode[d->mode]);
-    } else {
-        snprintf(temp, 512, "^fg(%s)%d ", PP_COL_MODE, d->mode);
-        pp.mode = realloc(pp.mode, strlen(temp));
-        sprintf(pp.mode, "^fg(%s)%d ", PP_COL_MODE, d->mode);
+    for (client *c = head; c; c = c->next) {
+        if (ISFFTM(c))
+            continue;
+        else
+            j++;
+        if (invert)
+            xcb_move_resize(dis, c->win, gaps,
+                            y + h / n * j + (c == head ? gaps : 0),
+                            ww - 2 * borders - 2 * gaps,
+                            h / n - 2 * borders - (c == head ? 2 : 1) * gaps);
+        else
+            xcb_move_resize(dis, c->win, ww / n * j + (c == head ? gaps : 0),
+                            y + gaps,
+                            ww / n - 2 * borders - (c == head ? 2 : 1) * gaps,
+                            h - 2 * borders - 2 * gaps);
     }
-    DEBUG("updatemode: leaving\n");
 }
 
-void updatetitle(client *c) {
-    DEBUG("updatetitle: entering\n");
-    xcb_icccm_get_text_property_reply_t reply;
-    xcb_generic_error_t *err = NULL;
-
-    if(!xcb_icccm_get_text_property_reply(dis, xcb_icccm_get_text_property(dis, c->win, netatoms[NET_WM_NAME]), &reply, &err))
-        if(!xcb_icccm_get_text_property_reply(dis, xcb_icccm_get_text_property(dis, c->win, XCB_ATOM_WM_NAME), &reply, &err))
-            return;
-
-    if(err) {
-        DEBUG("updatetitle: leaving, error\n");
-        free(err);
-        return;
-    }
-
-    // TODO: encoding
-    if(!reply.name || !reply.name_len)
-        return;
-     
-    free(c->title);
-    c->title = malloc_safe(reply.name_len+1);  
-    strncpy(c->title, reply.name, reply.name_len); 
-    xcb_icccm_get_text_property_reply_wipe(&reply);
-    DEBUG("updatetitle: leaving\n");
-}
-
-void updatews() {
-    DEBUG("updatews: entering\n");
-    desktop *d = NULL; client *c = NULL; monitor *m = NULL;
-    bool urgent = false; 
-    char *tags_ws[] = PP_TAGS_WS;
-    char t1[512] = { "" };
-    char t2[512] = { "" };
-    #if DEBUG
-    int count = 0;
-    #endif
-
-    for (int w = 0, i = 0; i < DESKTOPS; i++, w = 0, urgent = false) {
-        for (d = &desktops[i], c = d->head; c; urgent |= c->isurgent, ++w, c = c->next); 
-        for (m = mons; m; m = m->next)
-            if (i == m->curr_dtop && w == 0)
-                w++;
-        
-        if (tags_ws[i])
-            snprintf(t2, 512, "^fg(%s)%s ", 
-                    d == &desktops[selmon->curr_dtop] ? PP_COL_CURRENT:urgent ? PP_COL_URGENT:w ? PP_COL_VISIBLE:PP_COL_HIDDEN, 
-                    tags_ws[i]);
-        else 
-            snprintf(t2, 512, "^fg(%s)%d ", 
-                    d == &desktops[selmon->curr_dtop] ? PP_COL_CURRENT:urgent ? PP_COL_URGENT:w ? PP_COL_VISIBLE:PP_COL_HIDDEN, 
-                    i + 1);
-        strncat(t1, t2, strlen(t2));
-        #if DEBUG
-        count += strlen(t2);
-        DEBUGP("updatews: count = %d\n", count);
-        #endif
-    }
-    pp.ws = (char *)realloc(pp.ws, strlen(t1) + 1);
-    strncpy(pp.ws, t1, strlen(t1));
-
-    DEBUG("updatews: leaving\n");
-}
-#endif
+/*
+ * fibonacci mode / fibonacci layout
+ * tile the windows based on the fibonacci series pattern.
+ * arrange windows in such a way that every new window shares
+ * half the space of the space taken by the last window
+ * inverting changes between right/down and right/up
+ */
+void fibonacci(int h, int y)
+{
+    int j = -1, x = gaps, tt = 0,
+        cw = ww - 2 * gaps - 2 * borders,
+        ch = h - 2 * gaps - 2 * borders;
 
+    for (client *n, *c = head; c; c = c->next) {
+        if (ISFFTM(c))
+            continue;
+        else
+            j++;
+        for (n = c->next; n; n = n->next)
+            if (!ISFFTM(n))
+                break;
 
-// find which monitor the given window belongs to
-monitor *wintomon(xcb_window_t w) {
-    DEBUG("wintomon: entering\n");
-    int x, y;
-    monitor *m; client *c;
-    int i; 
-
-    if(w == screen->root && getrootptr(&x, &y)) {
-        DEBUG("wintomon: leaving, returning ptrtomon\n");
-        return ptrtomon(x, y);
-    }
-     
-    for (i = 0, m = mons; i < nmons; m = m->next, i++)
-        for (c = desktops[m->curr_dtop].head; c; c = c->next)
-            if(c->win == w) {
-                DEBUG("wintomon: leaving, returning found monitor\n");
-                return m;
-            }
-    
-    DEBUG("wintomon: leaving, returning NULL monitor\n");
-    return NULL;
-}
+        /*
+         * not the last window in stack ? -> half the client size, and also
+         * check if we have too many windows to keep them larger than MINWSZ
+         */
+        if (n
+            && ch > MINWSZ * 2 + borders + gaps
+            && cw > MINWSZ * 2 + borders + gaps) {
+            (j & 1) ? (ch = ch / 2 - borders - gaps / 2)
+                    : (cw = cw / 2 - borders - gaps / 2);
+            tt = j;
+        }
 
-// wrapper to get xcb keycodes from keysymbol
-xcb_keycode_t* xcb_get_keycodes(xcb_keysym_t keysym) {
-    xcb_key_symbols_t *keysyms;
-    xcb_keycode_t     *keycode;
+        /* not the master client ? -> shift client right or down (or up) */
+        if (j) {
+            (j & 1) ? (x = x + cw + 2 * borders + gaps)
+                    : (y = invert ? (y - ch - 2 * borders - gaps)
+                                  : (y + ch + 2 * borders + gaps));
 
-    if (!(keysyms = xcb_key_symbols_alloc(dis))) return NULL;
-        keycode = xcb_key_symbols_get_keycode(keysyms, keysym);
-    xcb_key_symbols_free(keysyms);
+            if (j & 1 && n && invert)
+                y += ch + 2 * borders + gaps;
+        }
 
-    return keycode;
+        /* if the window does not fit in the stack, do not jam it in there */
+        if (j <= tt + 1)
+            xcb_move_resize(dis, c->win, x, y + gaps, cw, ch);
+    }
 }
 
-// EVENTS
-
-#define CLEANMASK(mask) (mask & ~(numlockmask | XCB_MOD_MASK_LOCK))
+/* switch a client from tiling to float and manage everything involved */
+void float_client(client *c)
+{
+    if (!c)
+        return;
 
-// wrapper to get xcb keysymbol from keycode
-static xcb_keysym_t xcb_get_keysym(xcb_keycode_t keycode) {
-    xcb_key_symbols_t *keysyms;
-    xcb_keysym_t       keysym;
+    c->isfloating = true;
 
-    if (!(keysyms = xcb_key_symbols_alloc(dis))) return 0;
-    keysym = xcb_key_symbols_get_keysym(keysyms, keycode, 0);
-    xcb_key_symbols_free(keysyms);
+    if (c->dim[0] && c->dim[1]) {
+        if (c->dim[0] < MINWSZ)
+            c->dim[0] = MINWSZ;
+        if (c->dim[1] < MINWSZ)
+            c->dim[1] = MINWSZ;
 
-    return keysym;
+        xcb_resize(dis, c->win, c->dim[0], c->dim[1]);
+    }
 }
 
-// wrapper to window get attributes using xcb */
-static void xcb_get_attributes(xcb_window_t *windows, xcb_get_window_attributes_reply_t **reply, unsigned int count) {
-    xcb_get_window_attributes_cookie_t cookies[count];
-    for (unsigned int i = 0; i < count; i++) cookies[i] = xcb_get_window_attributes(dis, windows[i]);
-    for (unsigned int i = 0; i < count; i++) reply[i]   = xcb_get_window_attributes_reply(dis, cookies[i], NULL); // TODO: Handle error
-}
+/*
+ * handles x-movement of floating windows
+ */
+void float_x(const Arg *arg)
+{
+    xcb_get_geometry_reply_t *r;
 
-// create a new client and add the new window
-// window should notify of property change events
-static client* addwindow(xcb_window_t w, desktop *d) {
-    DEBUG("addwindow: entering\n");
-    client *c, *t = prev_client(d->head, d);
- 
-    if (!(c = (client *)malloc_safe(sizeof(client)))) err(EXIT_FAILURE, "cannot allocate client");
-
-    if (!d->head) d->head = c;
-    else if (t) t->next = c; 
-    else d->head->next = c;
-
-    DEBUGP("addwindow: d->count = %d\n", d->count);
-
-    unsigned int values[1] = { XCB_EVENT_MASK_PROPERTY_CHANGE|(FOLLOW_MOUSE?XCB_EVENT_MASK_ENTER_WINDOW:0) };
-    xcb_change_window_attributes_checked(dis, (c->win = w), XCB_CW_EVENT_MASK, values);
-    DEBUG("addwindow: leaving\n");
-    return c;
-}
+    if (!arg->i || !current)
+        return;
 
-// find which client the given window belongs to
-static client *wintoclient(xcb_window_t w) {
-    DEBUG("wintoclient: entering\n");
-    client *c = NULL;
-    int i;
- 
-    for (i = 0; i < DESKTOPS; i++)
-        for (c = desktops[i].head; c; c = c->next)
-            if(c->win == w) {
-                DEBUG("wintoclient: leaving, returning found client\n");
-                return c;
-            }
-    
-    DEBUG("wintoclient: leaving, returning NULL client\n");
-    return NULL;
-}
+    if (!current->isfloating) {
+        float_client(current);
+        tile();
+    }
 
-// remove the specified client
-//
-// note, the removing client can be on any desktop,
-// we must return back to the current focused desktop.
-// if c was the previously focused, prevfocus must be updated
-// else if c was the current one, current must be updated.
-static void removeclient(client *c, desktop *d, const monitor *m) {
-    DEBUG("removeclient: entering\n"); 
-    client **p = NULL;
-    for (p = &d->head; *p && (*p != c); p = &(*p)->next);
-    if (!p) 
-        return; 
-    else 
-        *p = c->next;
-    if (c == d->prevfocus) 
-        d->prevfocus = prev_client(d->current, d);
-    if (c == d->current) {
-        d->current = d->prevfocus ? d->prevfocus:d->head;
-        d->prevfocus = prev_client(d->current, d);
-    }
-
-    if (!c->isfloating) {
-        d->count -= 1;
-        tileremove(c, d, m);
-    } else if (d->current)
-        setclientborders(d, d->current, m);
-    free(c->title);
-    free(c); c = NULL; 
-    #if PRETTY_PRINT
-    updatews();
-    desktopinfo();
-    #endif
-    DEBUG("removeclient: leaving\n");
+    r = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win), NULL);
+    r->x += arg->i;
+    xcb_move(dis, current->win, r->x, r->y);
 }
 
+/*
+ * handles y-movement of floating windows
+ */
+void float_y(const Arg *arg)
+{
+    xcb_get_geometry_reply_t *r;
 
-// on the press of a button check to see if there's a binded function to call 
-// TODO: if we make the mouse able to switch monitors we could eliminate a call
-//       to wintomon
-void buttonpress(xcb_generic_event_t *e) {
-    DEBUG("buttonpress: entering\n");
-    xcb_button_press_event_t *ev = (xcb_button_press_event_t*)e; 
-    monitor *m = wintomon(ev->event);
-    client *c = wintoclient(ev->event);
+    if (!arg->i || !current)
+        return;
 
-    #if CLICK_TO_FOCUS 
-    if (ev->detail == XCB_BUTTON_INDEX_1) {
-        if (m && m != selmon) {
-            monitor *mold = selmon;
-            client *cold = desktops[selmon->curr_dtop].current;
-            selmon = m;
-            #if PRETTY_PRINT
-            updatews();
-            updatemode();
-            updatedir();
-            desktopinfo();
-            #endif
-            if (cold)
-                setclientborders(&desktops[mold->curr_dtop], cold, mold);
-        }
-     
-        if (c && c != desktops[m->curr_dtop].current)
-            focus(c, &desktops[m->curr_dtop], m);
-    }
-    #endif
-    
-    for (unsigned int i=0; i<LENGTH(buttons); i++)
-        if (buttons[i].func && buttons[i].button == ev->detail && CLEANMASK(buttons[i].mask) == CLEANMASK(ev->state)) {
-            if (desktops[m->curr_dtop].current != c) focus(c, &desktops[m->curr_dtop], m);
-            buttons[i].func(&(buttons[i].arg));
-        }
+    if (!current->isfloating) {
+        float_client(current);
+        tile();
+    }
 
-    #if CLICK_TO_FOCUS
-    xcb_allow_events(dis, XCB_ALLOW_REPLAY_POINTER, ev->time);
-    xcb_flush(dis);
-    #endif
-    DEBUG("buttonpress: leaving\n");
+    r = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win), NULL);
+    r->y += arg->i;
+    xcb_move(dis, current->win, r->x, r->y);
 }
 
-// To change the state of a mapped window, a client MUST
-// send a _NET_WM_STATE client message to the root window
-// message_type must be _NET_WM_STATE
-//   data.l[0] is the action to be taken
-//   data.l[1] is the property to alter three actions:
-//   - remove/unset _NET_WM_STATE_REMOVE=0
-//   - add/set _NET_WM_STATE_ADD=1,
-//   - toggle _NET_WM_STATE_TOGGLE=2
-//
-// check if window requested fullscreen or activation
-void clientmessage(xcb_generic_event_t *e) {
-    DEBUG("clientmessage: entering\n");
-
-    xcb_client_message_event_t *ev = (xcb_client_message_event_t*)e;
-    client *c = wintoclient(ev->window);
-    desktop *d = &desktops[selmon->curr_dtop]; 
-    if (!c) 
+/*
+ * focus the (first) master window, or switch back to the slave previously
+ * focussed, toggling between them
+ */
+void focusmaster()
+{
+    if (!head || !current || (current == head && !head->next)
+        || prevfocus->isminimized)
         return;
 
-    if (c && ev->type                      == netatoms[NET_WM_STATE]
-          && ((unsigned)ev->data.data32[1] == netatoms[NET_FULLSCREEN]
-          ||  (unsigned)ev->data.data32[2] == netatoms[NET_FULLSCREEN])) {
-            if (!(c->isfloating || c->istransient) || !d->head->next)
-                retile(d, selmon);
-    } else if (c && ev->type == netatoms[NET_ACTIVE]) 
-        focus(c, d, selmon);
-
-    DEBUG("clientmessage: leaving\n");
-}
-
-desktop *clienttodesktop(client *c) {
-    DEBUG("clienttodesktop: entering\n");
-    client *n = NULL; desktop *d = NULL;
-    int i;
- 
-    for (i = 0; i < DESKTOPS; i++)
-        for (d = &desktops[i], n = d->head; n; n = n->next)
-            if(n == c) {
-                DEBUGP("clienttodesktop: leaving, returning found desktop #%d\n", i);
-                return d;
-            }
-    
-    DEBUG("clienttodesktop: leaving, returning NULL desktop\n");
-    return NULL;
+    /* fix for glitchy toggle behaviour between head and head->next */
+    if (current == head->next)
+        prevfocus = current;
+
+    if (current == head)
+        update_current(prevfocus);
+    else
+        update_current(head);
 }
 
-// a configure request means that the window requested changes in its geometry
-// state. if the window doesnt have a client set the appropriate values as 
-// requested, else fake it.
-void configurerequest(xcb_generic_event_t *e) {
-    DEBUG("configurerequest: entering\n");
-    xcb_configure_request_event_t *ev = (xcb_configure_request_event_t*)e; 
-    unsigned int v[7];
-    unsigned int i = 0;
-    monitor *m; client *c; 
-   
-    if (!(c = wintoclient(ev->window))) { // if it has no client, configure it
-        if ((m = wintomon(ev->window))) {
-            DEBUGP("configurerequest: x: %d y: %d w: %d h: %d\n", ev->x, ev->y, ev->width, ev->height);
-
-            if (ev->value_mask & XCB_CONFIG_WINDOW_X) {
-                DEBUGP("configurerequest: m->x: %d\n", m->x);
-                if (ev->x > m->x)
-                    v[i++] = ev->x;
-                else
-                    v[i++] = (m->x + ev->x);
-            }
-            if (ev->value_mask & XCB_CONFIG_WINDOW_Y) {
-                DEBUGP("configurerequest: m->y: %d\n", m->y);
-                if (ev->y > m->y)
-                    v[i++] = (ev->y + (desktops[m->curr_dtop].showpanel && TOP_PANEL) ? PANEL_HEIGHT : 0);
-                else 
-                    v[i++] = ((m->y + ev->y) + (desktops[m->curr_dtop].showpanel && TOP_PANEL) ? PANEL_HEIGHT : 0);
-            }
-        }
-        else {
-            if (ev->value_mask & XCB_CONFIG_WINDOW_X) {
-                DEBUGP("configurerequest: selmon->x: %d\n", selmon->x);
-                v[i++] = ev->x;
-            }
-            if (ev->value_mask & XCB_CONFIG_WINDOW_Y) {
-                DEBUGP("configurerequest: selmon->y: %d\n", selmon->y);
-                v[i++] = (ev->y + (desktops[selmon->curr_dtop].showpanel && TOP_PANEL) ? PANEL_HEIGHT : 0);
-            }
-        }
+/* find and focus the client which received
+ * the urgent hint in the current desktop */
+void focusurgent()
+{
+    client *c;
+    int cd = current_desktop, d = 0;
 
-        if (ev->value_mask & XCB_CONFIG_WINDOW_WIDTH) {
-            DEBUG("configurerequest: width\n");
-            v[i++] = (ev->width  < selmon->w - BORDER_WIDTH) ? ev->width  : selmon->w - BORDER_WIDTH;
-        }
-        if (ev->value_mask & XCB_CONFIG_WINDOW_HEIGHT) {
-            DEBUG("configurerequest: height\n");
-            v[i++] = (ev->height < selmon->h - BORDER_WIDTH) ? ev->height : selmon->h - BORDER_WIDTH;
-        }
-        if (ev->value_mask & XCB_CONFIG_WINDOW_BORDER_WIDTH) {
-            DEBUG("configurerequest: border_width\n");
-            v[i++] = ev->border_width;
-        }
-        if (ev->value_mask & XCB_CONFIG_WINDOW_SIBLING) {
-            DEBUG("configurerequest: sibling\n");
-            v[i++] = ev->sibling;
-        }
-        if (ev->value_mask & XCB_CONFIG_WINDOW_STACK_MODE) {
-            DEBUG("configurerequest: stack_mode\n");
-            v[i++] = ev->stack_mode;
+    for (c = head; c && !c->isurgent; c = c->next);
+    if (c) {
+        update_current(c);
+        return;
+    } else {
+        for (bool f = false; d < DESKTOPS && !f; d++) {
+            for (select_desktop(d), c = head; c && !(f = c->isurgent);
+            c = c->next);
         }
-        xcb_configure_window_checked(dis, ev->window, ev->value_mask, v);
     }
-    else { // has a client, fake configure it
-        xcb_send_event(dis, false, c->win, XCB_EVENT_MASK_STRUCTURE_NOTIFY, (char*)ev);
+    select_desktop(cd);
+    if (c) {
+        change_desktop(&(Arg){.i = --d});
+        update_current(c);
     }
-    xcb_flush(dis);
-    DEBUG("configurerequest: leaving\n");
 }
 
-// a destroy notification is received when a window is being closed
-// on receival, remove the appropriate client that held that window
-void destroynotify(xcb_generic_event_t *e) {
-    DEBUG("destroynotify: entering\n");   
-    xcb_destroy_notify_event_t *ev = (xcb_destroy_notify_event_t*)e;
-    client *c = wintoclient(ev->window);
-    desktop *d = clienttodesktop(c);
-    monitor *m = wintomon(ev->window);
-    if (c) 
-        removeclient(c, d, m); 
-    #if PRETTY_PRINT
-    desktopinfo();
-    #endif
-    DEBUG("destroynotify: leaving\n");
-}
+/* get a pixel with the requested color
+ * to fill some window area - borders */
+unsigned int getcolor(char *color)
+{
+    xcb_colormap_t map = screen->default_colormap;
+    xcb_alloc_color_reply_t *c;
+    unsigned int r, g, b, rgb, pixel;
 
-// TODO: we dont need this event for FOLLOW_MOUSE false
-// when the mouse enters a window's borders
-// the window, if notifying of such events (EnterWindowMask)
-// will notify the wm and will get focus
-void enternotify(xcb_generic_event_t *e) {
-    DEBUG("enternotify: entering\n");
-    xcb_enter_notify_event_t *ev = (xcb_enter_notify_event_t*)e;  
+    rgb = xcb_get_colorpixel(color);
+    r = rgb >> 16; g = rgb >> 8 & 0xFF; b = rgb & 0xFF;
+    c = xcb_alloc_color_reply(dis, xcb_alloc_color(dis, map, r * 257, g * 257,
+                                                   b * 257), NULL);
+    if (!c)
+        errx(EXIT_FAILURE, "error: cannot allocate color '%s'\n", color);
 
-    if (!FOLLOW_MOUSE || ev->mode != XCB_NOTIFY_MODE_NORMAL || ev->detail == XCB_NOTIFY_DETAIL_INFERIOR) {
-        DEBUG("enternotify: leaving under user FOLLOW_MOUSE setting or event rules to not enter\n");
-        return;
-    }
+    pixel = c->pixel;
+    free(c);
 
-    client *c = wintoclient(ev->event);
-    if (!c) {
-        DEBUG("enternotify: leaving NULL client\n");
-        return;
-    }
-    
-    monitor *m = NULL;
-    if((m = wintomon(ev->event)) && m != selmon) {
-        monitor *mold = selmon;
-        client *cold = desktops[selmon->curr_dtop].current;
-        selmon = m;
-        #if PRETTY_PRINT
-        updatews();
-        updatemode();
-        updatedir();
-        #endif
-        if (cold)
-            setclientborders(&desktops[mold->curr_dtop], cold, mold);
-    
-    }
-
-    desktop *d = &desktops[selmon->curr_dtop]; 
-    DEBUGP("enternotify: c->xp: %f c->yp: %f c->wp: %f c->hp: %f\n", 
-            (selmon->w * c->xp), (selmon->h * c->yp), (selmon->w * c->wp), (selmon->h * c->hp));
-    focus(c, d, selmon);
-    DEBUG("enternotify: leaving\n");
-}
-
-#if PRETTY_PRINT
-// Expose event means we should redraw our windows
-void expose(xcb_generic_event_t *e) { 
-    monitor *m;
-    xcb_expose_event_t *ev = (xcb_expose_event_t*)e;
-
-    if(ev->count == 0 && (m = wintomon(ev->window))){
-        // redraw windows - xcb_flush?
-        desktopinfo();
-    }
-}    
-#endif
+    return pixel;
+}
 
-// events which are generated by clients
-void focusin(xcb_generic_event_t *e) {
-    DEBUG("focusin: entering\n");
-    xcb_focus_in_event_t *ev = (xcb_focus_in_event_t*)e;
+/* set the given client to listen to button events (presses / releases) */
+void grabbuttons(client *c)
+{
+    unsigned int modifiers[] = { 0, XCB_MOD_MASK_LOCK, numlockmask,
+                                 numlockmask|XCB_MOD_MASK_LOCK };
 
-    if (ev->mode == XCB_NOTIFY_MODE_GRAB || ev->mode == XCB_NOTIFY_MODE_UNGRAB) {
-        DEBUG("focusin: event for grab/ungrab, ignoring\n");
-        return;
-    }
+    xcb_ungrab_button(dis, XCB_BUTTON_INDEX_ANY, c->win, XCB_GRAB_ANY);
+    for (unsigned int b = 0; b < LENGTH(buttons); b++)
+        for (unsigned int m = 0; m < LENGTH(modifiers); m++)
+            if (CLICK_TO_FOCUS)
+                xcb_grab_button(dis, 1, c->win, XCB_EVENT_MASK_BUTTON_PRESS,
+                                XCB_GRAB_MODE_SYNC, XCB_GRAB_MODE_ASYNC,
+                                XCB_WINDOW_NONE, XCB_CURSOR_NONE,
+                                XCB_BUTTON_INDEX_ANY, XCB_BUTTON_MASK_ANY);
+            else
+                xcb_grab_button(dis, 1, c->win, XCB_EVENT_MASK_BUTTON_PRESS,
+                                XCB_GRAB_MODE_SYNC, XCB_GRAB_MODE_ASYNC,
+                                XCB_WINDOW_NONE, XCB_CURSOR_NONE,
+                                buttons[b].button,
+                                buttons[b].mask|modifiers[m]);
+}
 
-    if (ev->detail == XCB_NOTIFY_DETAIL_POINTER) {
-        DEBUG("focusin: notify detail is pointer, ignoring this event\n");
-        return;
-    }
+/* the wm should listen to key presses */
+void grabkeys(void)
+{
+    xcb_keycode_t *keycode;
+    unsigned int modifiers[] = { 0, XCB_MOD_MASK_LOCK, numlockmask,
+                                 numlockmask|XCB_MOD_MASK_LOCK };
 
-    if(!desktops[selmon->curr_dtop].current && ev->event != desktops[selmon->curr_dtop].current->win)
-        xcb_set_input_focus(dis, XCB_INPUT_FOCUS_POINTER_ROOT, desktops[selmon->curr_dtop].current->win,
-                            XCB_CURRENT_TIME);
+    xcb_ungrab_key(dis, XCB_GRAB_ANY, screen->root, XCB_MOD_MASK_ANY);
+    for (unsigned int i = 0; i < LENGTH(keys); i++) {
+        keycode = xcb_get_keycodes(keys[i].keysym);
+        for (unsigned int k = 0; keycode[k] != XCB_NO_SYMBOL; k++)
+            for (unsigned int m = 0; m < LENGTH(modifiers); m++)
+                xcb_grab_key(dis, 1, screen->root, keys[i].mod | modifiers[m],
+                             keycode[k], XCB_GRAB_MODE_ASYNC,
+                             XCB_GRAB_MODE_ASYNC);
+        free(keycode);
+    }
+}
 
-    DEBUG("focusin: leaving\n");
+/* arrange windows in a grid */
+void grid(int hh, int cy)
+{
+    int n = 0, cols = 0, cn = 0, rn = 0, i = -1;
+    for (client *c = head; c; c = c->next)
+        if (!ISFFTM(c))
+            ++n;
+    if (!n)
+        return;
+    for (cols = 0; cols <= n / 2; cols++)
+        if (cols * cols >= n)
+            break; /* emulate square root */
+    if (n == 5)
+        cols = 2;
+
+    int rows = n / cols,
+        ch = hh - gaps,
+        cw = (ww - gaps) / (cols ? cols : 1);
+    for (client *c = head; c; c = c->next) {
+        if (ISFFTM(c))
+            continue;
+        else
+            ++i;
+        if (i / rows + 1 > cols - n % cols)
+            rows = n / cols + 1;
+        xcb_move_resize(dis, c->win, cn * cw + gaps,
+                        cy + rn * ch / rows + gaps,
+                        cw - 2 * borders - gaps,
+                        ch / rows - 2 * borders - gaps);
+        if (++rn >= rows) {
+            rn = 0;
+            cn++;
+        }
+    }
 }
 
-// on the press of a key check to see if there's a binded function to call
-void keypress(xcb_generic_event_t *e) {
-    DEBUG("keypress: entering\n");
+/* invert v-stack left-right */
+void invertstack()
+{
+    if ((invert = !invert))
+        desktops[current_desktop].invert = invert;
+    tile();
+}
+
+/* on the press of a key check to see if there's a binded function to call */
+void keypress(xcb_generic_event_t *e)
+{
     xcb_key_press_event_t *ev       = (xcb_key_press_event_t *)e;
     xcb_keysym_t           keysym   = xcb_get_keysym(ev->detail);
+
     DEBUGP("xcb: keypress: code: %d mod: %d\n", ev->detail, ev->state);
-    for (unsigned int i=0; i < LENGTH(keys); i++)
-        if (keysym == keys[i].keysym && CLEANMASK(keys[i].mod) == CLEANMASK(ev->state) && keys[i].func)
+    for (unsigned int i = 0; i < LENGTH(keys); i++)
+        if (keysym == keys[i].keysym &&
+            CLEANMASK(keys[i].mod) == CLEANMASK(ev->state) &&
+            keys[i].func)
                 keys[i].func(&keys[i].arg);
+}
+
+/* explicitly kill a client - close the highlighted window
+ * send a delete message and remove the client */
+void killclient()
+{
+    if (!current)
+        return;
+    xcb_icccm_get_wm_protocols_reply_t reply;
+    unsigned int n = 0;
+    bool got = false;
 
-    DEBUG("keypress: leaving\n");
+    if (xcb_icccm_get_wm_protocols_reply(dis,
+        xcb_icccm_get_wm_protocols(dis, current->win, wmatoms[WM_PROTOCOLS]),
+        &reply, NULL)) { /* TODO: Handle error? */
+        for (; n != reply.atoms_len; ++n)
+            if ((got = reply.atoms[n] == wmatoms[WM_DELETE_WINDOW]))
+                break;
+        xcb_icccm_get_wm_protocols_reply_wipe(&reply);
+    }
+    if (got)
+        deletewindow(current->win);
+    else
+        xcb_kill_client(dis, current->win);
+    removeclient(current);
 }
 
-void mappingnotify(xcb_generic_event_t *e) {
-    xcb_mapping_notify_event_t *ev = (xcb_mapping_notify_event_t*)e;
-    //xcb_keysym_t           keysym   = xcb_get_keysym(ev->detail);
-
-    //xcb_refresh_keyboard_mapping(keysym, ev);
-    if(ev->request == XCB_MAPPING_NOTIFY)
-        grabkeys();
-}
-
-// a map request is received when a window wants to display itself
-// if the window has override_redirect flag set then it should not be handled
-// by the wm. if the window already has a client then there is nothing to do.
-//
-// get the window class and name instance and try to match against an app rule.
-// create a client for the window, that client will always be current.
-// check for transient state, and fullscreen state and the appropriate values.
-// if the desktop in which the window was spawned is the current desktop then
-// display the window, else, if set, focus the new desktop.
-void maprequest(xcb_generic_event_t *e) {
-    DEBUG("maprequest: entering\n");
-    client *c = NULL; 
-    xcb_map_request_event_t            *ev = (xcb_map_request_event_t*)e;
-    xcb_window_t                       windows[] = { ev->window }, transient = 0;
+/* focus the previously focused desktop */
+void last_desktop()
+{
+    change_desktop(&(Arg){.i = previous_desktop});
+}
+
+/* a map request is received when a window wants to display itself
+ * if the window has override_redirect flag set then it should not be handled
+ * by the wm. if the window already has a client then there is nothing to do.
+ *
+ * get the window class and name instance and try to match against an app rule.
+ * create a client for the window, that client will always be current.
+ * check for transient state, and fullscreen state and the appropriate values.
+ * if the desktop in which the window was spawned is the current desktop then
+ * display the window, else, if set, focus the new desktop.
+ */
+void maprequest(xcb_generic_event_t *e)
+{
+    xcb_map_request_event_t            *ev = (xcb_map_request_event_t *)e;
+    xcb_window_t                       windows[] = {ev->window}, transient = 0;
     xcb_get_window_attributes_reply_t  *attr[1];
-    xcb_icccm_get_wm_class_reply_t     ch;
     xcb_get_geometry_reply_t           *geometry;
     xcb_get_property_reply_t           *prop_reply;
+    xcb_ewmh_get_atoms_reply_t         type;
+    xcb_get_property_cookie_t          cookie;
+    xcb_ewmh_get_utf8_strings_reply_t  wtitle;
+    bool atom_success = false;
 
     xcb_get_attributes(windows, attr, 1);
-    if (!attr[0] || attr[0]->override_redirect) return;
-    c = wintoclient(ev->window);
-    if (c) return; 
+    if (!attr[0] || attr[0]->override_redirect) {
+        free(attr[0]);
+        return;
+    } else {
+        free(attr[0]);
+    }
+
+    if (wintoclient(ev->window))
+        return;
+    if (xcb_ewmh_get_wm_window_type_reply(ewmh,
+                                      xcb_ewmh_get_wm_window_type(ewmh,
+                                      ev->window), &type, NULL) == 1) {
+        for (unsigned int i = 0; i < type.atoms_len; i++) {
+            xcb_atom_t a = type.atoms[i];
+            if (a == ewmh->_NET_WM_WINDOW_TYPE_TOOLBAR
+                || a == ewmh->_NET_WM_WINDOW_TYPE_DOCK) {
+                xcb_ewmh_get_atoms_reply_wipe(&type);
+                return;
+            }
+        }
+        atom_success = true;
+    }
+
+    DEBUG("xcb: map request");
 
     bool follow = false, floating = false;
-    int cd = selmon->curr_dtop, newdsk = selmon->curr_dtop;
-    if (xcb_icccm_get_wm_class_reply(dis, xcb_icccm_get_wm_class(dis, ev->window), &ch, NULL)) { // TODO: error handling
-        DEBUGP("class: %s instance: %s\n", ch.class_name, ch.instance_name);
-        for (unsigned int i=0; i<LENGTH(rules); i++)
-            if (strstr(ch.class_name, rules[i].class) || strstr(ch.instance_name, rules[i].class)) {
+    int cd = current_desktop, newdsk = current_desktop;
+
+    cookie = xcb_ewmh_get_wm_name_unchecked(ewmh, ev->window);
+
+    if (xcb_ewmh_get_wm_name_reply(ewmh, cookie, &wtitle, (void *)0)) {
+        DEBUGP("EWMH window title: %s\n", wtitle.strings);
+        if (!strcmp(wtitle.strings, SCRPDNAME)) {
+            client *c;
+
+            if (!(c = (client *)calloc(1, sizeof(client))))
+                err(EXIT_FAILURE, "cannot allocate client");
+
+            unsigned int values[1] = {XCB_EVENT_MASK_PROPERTY_CHANGE|
+                                      (FOLLOW_MOUSE
+                                      ? XCB_EVENT_MASK_ENTER_WINDOW : 0)};
+            xcb_change_window_attributes_checked(dis, (c->win = ev->window),
+                                                 XCB_CW_EVENT_MASK, values);
+            scrpd = c;
+            xcb_map_window(dis, scrpd->win);
+            xcb_move(dis, scrpd->win, -2 * ww, 0);
+            xcb_ewmh_get_utf8_strings_reply_wipe(&wtitle);
+
+            if (atom_success) {
+                xcb_ewmh_get_atoms_reply_wipe(&type);
+            }
+            return;
+        }
+        for (unsigned int i = 0; i < LENGTH(appruleregex); i++)
+            if (!regexec(&appruleregex[i], &wtitle.strings[0], 0, NULL, 0)) {
                 follow = rules[i].follow;
-                newdsk = (rules[i].desktop < 0) ? selmon->curr_dtop:rules[i].desktop;
+                newdsk = (rules[i].desktop < 0 ||
+                          rules[i].desktop >= DESKTOPS) ? current_desktop
+                                                        : rules[i].desktop;
                 floating = rules[i].floating;
                 break;
             }
-        xcb_icccm_get_wm_class_reply_wipe(&ch);
-    } 
-     
-    if (cd != newdsk) selmon->curr_dtop = newdsk;
-    c = addwindow(ev->window, &desktops[newdsk]);
-
-    xcb_icccm_get_wm_transient_for_reply(dis, xcb_icccm_get_wm_transient_for_unchecked(dis, ev->window), &transient, NULL); // TODO: error handling
-    c->istransient = transient?true:false;
-    c->isfloating  = floating || desktops[newdsk].mode == FLOAT || c->istransient;
-
-    if (c->istransient || c->isfloating) {
-        if ((geometry = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, ev->window), NULL))) { // TODO: error handling
-            DEBUGP("geom: %ux%u+%d+%d\n", geometry->width, geometry->height, geometry->x, geometry->y);
-            c->x = selmon->x + geometry->x;
-            c->y = selmon->y + geometry->y;
-            c->w = geometry->width;
-            c->h = geometry->height;
-            free(geometry);
-        }
+
+        xcb_ewmh_get_utf8_strings_reply_wipe(&wtitle);
+    }
+    if (atom_success) {
+        for (unsigned int i = 0; i < type.atoms_len; i++) {
+            xcb_atom_t a = type.atoms[i];
+            if (a == ewmh->_NET_WM_WINDOW_TYPE_SPLASH
+                || a == ewmh->_NET_WM_WINDOW_TYPE_DIALOG
+                || a == ewmh->_NET_WM_WINDOW_TYPE_DROPDOWN_MENU
+                || a == ewmh->_NET_WM_WINDOW_TYPE_POPUP_MENU
+                || a == ewmh->_NET_WM_WINDOW_TYPE_TOOLTIP
+                || a == ewmh->_NET_WM_WINDOW_TYPE_NOTIFICATION) {
+                floating = true;
+            }
+        }
+        xcb_ewmh_get_atoms_reply_wipe(&type);
+    }
+
+    /* might be useful in future */
+    if ((geometry = xcb_get_geometry_reply(dis,
+                                           xcb_get_geometry(dis, ev->window),
+                                           NULL))) { /* TODO: error handling */
+        DEBUGP("geom: %ux%u+%d+%d\n", geometry->width, geometry->height,
+                                      geometry->x,     geometry->y);
+        free(geometry);
     }
 
-    if (!ISFT(c))
-        desktops[newdsk].count += 1;
-        
-    prop_reply  = xcb_get_property_reply(dis, xcb_get_property_unchecked(dis, 0, ev->window, netatoms[NET_WM_STATE], XCB_ATOM_ATOM, 0, 1), NULL); // TODO: error handling
-    if (prop_reply) { 
+    if (cd != newdsk)
+        select_desktop(newdsk);
+    client *c = addwindow(ev->window);
+
+    xcb_icccm_get_wm_transient_for_reply(dis,
+                    xcb_icccm_get_wm_transient_for_unchecked(dis, ev->window),
+                    &transient, NULL); /* TODO: error handling */
+    c->istransient = transient ? true : false;
+    c->isfloating  = floating || c->istransient;
+
+    prop_reply = xcb_get_property_reply(dis, xcb_get_property_unchecked(
+                                    dis, 0, ev->window, netatoms[NET_WM_STATE],
+                                    XCB_ATOM_ATOM, 0, 1), NULL);
+                                    /* TODO: error handling */
+    if (prop_reply) {
+        if (prop_reply->format == 32) {
+            xcb_atom_t *v = xcb_get_property_value(prop_reply);
+            for (unsigned int i = 0; i < prop_reply->value_len; i++)
+                DEBUGP("%d : %d\n", i, v[0]);
+            setfullscreen(c, (v[0] == netatoms[NET_FULLSCREEN]));
+        }
         free(prop_reply);
-    } 
+    }
 
-    monitor *m = wintomon(c->win);
+    /** information for stdout **/
+    DEBUGP("transient: %d\n", c->istransient);
+    DEBUGP("floating:  %d\n", c->isfloating);
+
+    if (cd != newdsk)
+        select_desktop(cd);
     if (cd == newdsk) {
-        tilenew(&desktops[selmon->curr_dtop], selmon); 
-        xcb_map_window(dis, c->win);  
+        tile();
+        if (show)
+            xcb_map_window(dis, c->win);
+        update_current(c);
+    } else if (follow) {
+        change_desktop(&(Arg){.i = newdsk});
+        update_current(c);
     }
-    else if (follow)
-        change_desktop(&(Arg){.i = newdsk}); 
-    focus(c, &desktops[m->curr_dtop], m);
     grabbuttons(c);
-    
-    #if PRETTY_PRINT
-    updatetitle(c);
-    if (!follow)
-        desktopinfo();
-    #endif
-
-    DEBUG("maprequest: leaving\n");
+
+    desktopinfo();
+
+    if (c->isfloating && AUTOCENTER)
+        centerwindow();
 }
 
-// property notify is called when one of the window's properties
-// is changed, such as an urgent hint is received
-void propertynotify(xcb_generic_event_t *e) {
-    DEBUG("propertynotify: entering\n");
-    xcb_property_notify_event_t *ev = (xcb_property_notify_event_t*)e;
-    xcb_icccm_wm_hints_t wmh;
-    client *c;
+/* maximize the current window, or if we are maximized, tile() */
+void maximize()
+{
+    xcb_get_geometry_reply_t *r;
+    int hh, cy;
 
-    c = wintoclient(ev->window);
-    if (!c) { 
-        DEBUG("propertynotify: leaving, NULL client\n");
+    if (!current)
         return;
-    }
 
-    #if PRETTY_PRINT
-    if (ev->atom == XCB_ATOM_WM_NAME) {
-        DEBUG("propertynotify: ev->atom == XCB_ATOM_WM_NAME\n");
-        updatetitle(c);
-        desktopinfo(); 
-    }
-    #endif
-    if (ev->atom != XCB_ICCCM_WM_ALL_HINTS) {
-        DEBUG("propertynotify: leaving, ev->atom != XCB_ICCCM_WM_ALL_HINTS\n");
-        return;
-    } 
-    if (xcb_icccm_get_wm_hints_reply(dis, xcb_icccm_get_wm_hints(dis, ev->window), &wmh, NULL)) { // TODO: error handling
-        c->isurgent = c != desktops[selmon->curr_dtop].current && (wmh.flags & XCB_ICCCM_WM_HINT_X_URGENCY);
-        DEBUG("propertynotify: got hint!\n");
-        return;
-    } 
+    hh = wh + (showpanel ? 0 : PANEL_HEIGHT);
+    cy = (TOP_PANEL && showpanel ? PANEL_HEIGHT : 0);
 
-    DEBUG("propertynotify: leaving\n");
-}
+    /* TODO: save floating geo before maximizing to reinstate floating ? */
+    /* if we float, reinstate tiling layout to exit maximize */
+    if (current->isfloating)
+        switch_mode(&(Arg){.i = mode});
 
-// windows that request to unmap should lose their
-// client, so no invisible windows exist on screen
-void unmapnotify(xcb_generic_event_t *e) {
-    DEBUG("unmapnotify: entering\n");
-    xcb_unmap_notify_event_t *ev = (xcb_unmap_notify_event_t *)e;
-    client *c = wintoclient(ev->window);
-    monitor *m = wintomon(ev->window);
-    if (c && ev->event != screen->root) removeclient(c, &desktops[selmon->curr_dtop], m);
-    #if PRETTY_PRINT
-    desktopinfo();
-    #endif
-    DEBUG("unmapnotify: leaving\n");
+    /* check if we are already maximized, using actual window size to check */
+    r = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win), NULL);
+    if (r->width == ww - 2 * gaps && r->height == hh - 2 * gaps) {
+        tile();
+        free(r);
+        return;
+    } else {
+        free(r);
+    }
+
+    xcb_move_resize(dis, current->win, gaps, cy + gaps,
+                    ww - 2 * gaps, hh - 2 * gaps);
 }
 
-// TILING
+/* push the current client down the miniq and minimize the window */
+void minimize()
+{
+    filo *tmp, *new;
 
-// each window should cover all the available screen space
-void monocle(int x, int y, int w, int h, const desktop *d, const monitor *m) {
-    DEBUG("monocle: entering\n");
-    int gap = d->gap; 
-    for (client *c = d->head; c; c = c->next) {
-        xcb_raise_window(dis, c->win);
-        if (d->mode == VIDEO)
-            xcb_move_resize(dis, c->win, x, (y - ((m->haspanel && TOP_PANEL) ? PANEL_HEIGHT:0)), w, (h + ((m->haspanel && !TOP_PANEL) ? PANEL_HEIGHT:0)));
-        else
-            xcb_move_resize(dis, c->win, (x + gap), (y + gap), (w - 2*gap), (h - 2*gap));
-    }
-    DEBUG("monocle: leaving\n");
-}
+    if (!current)
+        return;
 
-void retile(desktop *d, const monitor *m) {
-    DEBUG("retile: entering\n");
-    int gap = d->gap;
-
-    if (d->mode == TILE || d->mode == FLOAT) {
-        int n = d->count;
-        DEBUGP("retile: d->count = %d\n", d->count);
-       
-        for (client *c = d->head; c; c=c->next) {
-            if (!c->isfloating) {
-                xcb_lower_window(dis, c->win);
-                if (n == 1) {
-                    c->gapx = c->gapy = c->gapw = c->gaph = gap;
-                    xcb_move_resize(dis, c->win, 
-                                    (c->x = m->x + (m->w * c->xp) + gap), 
-                                    (c->y = m->y + (m->h * c->yp) + gap), 
-                                    (c->w = (m->w * c->wp) - 2*gap), 
-                                    (c->h = (m->h * c->hp) - 2*gap));
-                }
-                else { 
-                    xcb_move_resize(dis, c->win, 
-                                    (c->x = m->x + (m->w * c->xp) + c->gapx), 
-                                    (c->y = m->y + (m->h * c->yp) + c->gapy), 
-                                    (c->w = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw), 
-                                    (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-                }
-            } else {
-                for ( ; c->x > m->x + m->w; c->x -= m->w);
-                for ( ; c->y > m->y + m->h; c->y -= m->h);
+    tmp = miniq[current_desktop];
+    while (tmp->next)
+        tmp = tmp->next;
 
-                for ( ; c->x < m->x; c->x += m->w);
-                for ( ; c->y < m->y; c->y += m->h);
-                
-                xcb_raise_window(dis, c->win);
-                xcb_move_resize(dis, c->win, c->x, c->y, c->w, c->h);
-            }
-        } 
-    }
-    else
-        monocle(m->x, m->y, m->w, m->h, d, m);
-    setdesktopborders(d, m);
+    /* we always have an empty filo at the end of the miniq */
+    new = calloc(1, sizeof(filo));
+    if (!new)
+        return;
 
-    DEBUG("retile: leaving\n");
-}
+    tmp->c = current;
+    tmp->next = new;
 
-void tilenew(desktop *d, const monitor *m) {
-    DEBUG("tilenew: entering\n");
-    client *c = d->current, *n;
-    int gap = d->gap; 
-
-    if (!d->head) {
-        DEBUG("tilenew: leaving, nothing to arrange\n");
-        return; // nothing to arange
-    }
-    if (c && c->isfloating) {
-        // try to find the first one behind the pointer
-        xcb_query_pointer_reply_t *pointer = xcb_query_pointer_reply(dis, xcb_query_pointer(dis, screen->root), 0);
-        if (!pointer) return;
-        int mx = pointer->root_x; int my = pointer->root_y;
-        for (c = d->head; c; c = c->next)
-            if(!ISFT(c) && INRECT(mx, my, c->x, c->y, c->w, c->h))
-                break;
-        // just find the first tiled client.
-        if (!c)
-            for (c = d->head; c; c = c->next)
-                if(!ISFT(c))
-                    break;
-    }
+    tmp->c->isminimized = true;
+    xcb_move(dis, tmp->c->win, -2 * ww, 0);
 
-    for (n = d->head; n && n->next; n = n->next);
-    if (ISFT(n)) {
-        if (!m || n->istransient)
-            xcb_move_resize(dis, n->win, n->x, n->y, n->w, n->h);
-        else // move floaters to the center of the screen
-            xcb_move_resize(dis, n->win, (n->x = m->x + (m->w/2 - n->w/2)), (n->y = m->y + (m->h/2 - n->h/2)), n->w, n->h);
-        xcb_raise_window(dis, n->win);
-    } else if (d->count == 1) {
-        DEBUG("tilenew: tiling empty monitor\n");
-        n->xp = 0; n->yp = 0; n->wp = 1; n->hp = 1;
-        if (m != NULL) {
-            if (d->mode == VIDEO) {
-                xcb_move_resize(dis, n->win, m->x, (m->y - ((m->haspanel && TOP_PANEL) ? PANEL_HEIGHT:0)), m->w, (m->h + ((m->haspanel && !TOP_PANEL) ? PANEL_HEIGHT:0)));
-                xcb_raise_window(dis, n->win);
-            } else {
-                xcb_move_resize(dis, n->win, (m->x + gap), (m->y + gap), (m->w - 2*gap), (m->h - 2*gap)); 
-                xcb_lower_window(dis, n->win);
-            }
-        } 
-    }
-    else {
-        tiledirection[d->direction](n, c);
-        adjustclientgaps(gap, c);
-        adjustclientgaps(gap, n);
-
-        if (m != NULL) { 
-            if (d->mode != MONOCLE && d->mode != VIDEO) {
-                xcb_move_resize(dis, c->win,
-                                (c->x = m->x + (m->w * c->xp) + c->gapx), 
-                                (c->y = m->y + (m->h * c->yp) + c->gapy), 
-                                (c->w = (m->w * c->wp) - 2*BORDER_WIDTH - c->gapx - c->gapw),
-                                (c->h = (m->h * c->hp) - 2*BORDER_WIDTH - c->gapy - c->gaph));
-                DEBUGP("tilenew: tiling current x:%f y:%f w:%f h:%f\n", (m->w * c->xp), (m->h * c->yp), (m->w * c->wp) , (m->h * c->hp));
-                xcb_lower_window(dis, c->win);
-                xcb_move_resize(dis, n->win, 
-                                (n->x = m->x + (m->w * n->xp) + n->gapx), 
-                                (n->y = m->y + (m->h * n->yp) + n->gapy), 
-                                (n->w = (m->w * n->wp) - 2*BORDER_WIDTH - n->gapx - n->gapw), 
-                                (n->h = (m->h * n->hp) - 2*BORDER_WIDTH - n->gapy - n->gaph));
-                DEBUGP("tilenew: tiling new x:%f y:%f w:%f h:%f\n", (m->w * n->xp), (m->h * n->yp), (m->w * n->wp), (m->h * n->hp));
-                xcb_lower_window(dis, n->win);
-            }
-            else
-                monocle(m->x, m->y, m->w, m->h, d, m);
-        }
+    client *t = head;
+    while (t) {
+        if (t && !t->isminimized)
+            break;
+        t = t->next;
     }
+    if (t)
+        update_current(t);
 
-    DEBUG("tilenew: leaving\n");
+    tile();
 }
 
-void tilenewbottom(client *n, client *c) {
-    DEBUG("tilenewbottom: entering\n"); 
-    n->xp = c->xp;
-    n->yp = c->yp + (c->hp/2);
-    n->wp = c->wp;
-    n->hp = (c->yp + c->hp) - n->yp;
-    c->hp = n->yp - c->yp;
-    DEBUG("tilenewbottom: leaving\n");
-}
-
-void tilenewleft(client *n, client *c) {
-    DEBUG("tilenewleft: entering\n");
-    n->xp = c->xp;
-    n->yp = c->yp;
-    n->wp = c->wp/2;
-    n->hp = c->hp;
-    c->xp = n->xp + n->wp;
-    c->wp = (n->xp + c->wp) - c->xp;
-    DEBUG("tilenewleft: leaving\n");
-}
-
-void tilenewright(client *n, client *c) {
-    DEBUG("tilenewright: entering\n");
-    n->xp = c->xp + (c->wp/2);
-    n->yp = c->yp;
-    n->wp = (c->xp + c->wp) - n->xp;
-    n->hp = c->hp;
-    c->wp = n->xp - c->xp;
-    DEBUG("tilenewright: leaving\n");
-}
-
-void tilenewtop(client *n, client *c) {
-    DEBUG("tilenewtop: entering\n");
-    n->xp = c->xp;
-    n->yp = c->yp;
-    n->wp = c->wp;
-    n->hp = c->hp/2;
-    c->yp = n->yp + n->hp;
-    c->hp = (n->yp + c->hp) - c->yp;
-    DEBUG("tilenewtop: leaving\n");
-}
-
-void tileremove(client *dead, desktop *d, const monitor *m) {
-    DEBUG("tileremove: entering\n");
-    int gap = d->gap, n = 0;
-    client **list;
-
-    n = d->count;
-    DEBUGP("tileremove: d->count = %d\n", d->count);
-
-    if (n == 1) {
-        DEBUG("tileremove: only one client; fitting screen\n");
-        client *c = NULL;
-        for (c = d->head; c && c->isfloating; c = c->next); //find the first non-floating
-        c->xp = 0; c->yp = 0; c->wp = 1; c->hp = 1;
-
-        if ((m != NULL) && (d->mode == TILE || d->mode == FLOAT)) {
-            adjustclientgaps(gap, c);
-            xcb_move_resize(dis, c->win, 
-                            (c->x = m->x + (m->w * c->xp) + c->gapx), 
-                            (c->y = m->y + (m->h * c->yp) + c->gapy), 
-                            (c->w = (m->w * c->wp) - 2*c->gapw), 
-                            (c->h = (m->h * c->hp) - 2*c->gaph));
-            setclientborders(d, c, m);
-        }
-        DEBUG("tileremove: leaving\n");
-        return;
-    }
-
-    list = (client**)malloc_safe(n * sizeof(client*));
-
-    if (findtouchingclients[TTOP](d, dead, list, &n)) {
-        // clients in list should gain the emptyspace
-        for (int i = 0; i < n; i++) {
-            list[i]->hp += dead->hp;
-            if (m != NULL && (d->mode == TILE || d->mode == FLOAT)) {
-                adjustclientgaps(gap, list[i]);
-                xcb_move_resize(dis, list[i]->win, 
-                                list[i]->x, 
-                                list[i]->y, 
-                                list[i]->w, 
-                                (list[i]->h = (m->h * list[i]->hp) - 2*BORDER_WIDTH - list[i]->gapy - list[i]->gaph));
-                setclientborders(d, list[i], m);
-            }
-        }
-        free(list);
-        DEBUG("tileremove: leaving\n");
+/* grab the pointer and get it's current position
+ * all pointer movement events will be reported until it's ungrabbed
+ * until the mouse button has not been released,
+ * grab the interesting events - button press/release and pointer motion
+ * and on on pointer movement resize or move the window under the curson.
+ * if the received event is a map request or a configure request call the
+ * appropriate handler, and stop listening for other events.
+ * Ungrab the poitner and event handling is passed back to run() function.
+ * Once a window has been moved or resized, it's marked as floating. */
+void mousemotion(const Arg *arg)
+{
+    xcb_get_geometry_reply_t  *geometry;
+    xcb_query_pointer_reply_t *pointer;
+    xcb_grab_pointer_reply_t  *grab_reply;
+    int mx, my, winx, winy, winw, winh, xw, yh;
+
+    if (!current)
+        return;
+    geometry = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win),
+                                      NULL); /* TODO: error handling */
+    if (geometry) {
+        winx = geometry->x;     winy = geometry->y;
+        winw = geometry->width; winh = geometry->height;
+        free(geometry);
+    } else {
         return;
     }
 
-    if (findtouchingclients[TLEFT](d, dead, list, &n)) {
-        // clients in list should gain the emptyspace
-        for (int i = 0; i < n; i++) {
-            list[i]->wp += dead->wp;
-            if (m != NULL && (d->mode == TILE || d->mode == FLOAT)) {
-                adjustclientgaps(gap, list[i]);
-                xcb_move_resize(dis, list[i]->win, 
-                                list[i]->x, 
-                                list[i]->y, 
-                                (list[i]->w = (m->w * list[i]->wp) - 2*BORDER_WIDTH - list[i]->gapx - list[i]->gapw), 
-                                list[i]->h);
-                setclientborders(d, list[i], m);
-            }
-        }
-        free(list);
-        DEBUG("tileremove: leaving\n");
+    pointer = xcb_query_pointer_reply(dis,
+                                      xcb_query_pointer(dis, screen->root), 0);
+    if (!pointer)
+        return;
+    mx = pointer->root_x;
+    my = pointer->root_y;
+
+    grab_reply = xcb_grab_pointer_reply(dis, xcb_grab_pointer(dis, 0,
+        screen->root,
+        BUTTONMASK|XCB_EVENT_MASK_BUTTON_MOTION|XCB_EVENT_MASK_POINTER_MOTION,
+        XCB_GRAB_MODE_ASYNC, XCB_GRAB_MODE_ASYNC, XCB_NONE, XCB_NONE,
+        XCB_CURRENT_TIME), NULL);
+
+    if (!grab_reply || grab_reply->status != XCB_GRAB_STATUS_SUCCESS) {
+        free(grab_reply);
         return;
+    } else {
+        free(grab_reply);
     }
 
-    if (findtouchingclients[TBOTTOM](d, dead, list, &n)) {
-        // clients in list should gain the emptyspace
-        for (int i = 0; i < n; i++) {
-            list[i]->yp = dead->yp;
-            list[i]->hp += dead->hp;
-            if (m != NULL && (d->mode == TILE || d->mode == FLOAT)) {
-                adjustclientgaps(gap, list[i]);
-                xcb_move_resize(dis, list[i]->win, 
-                                list[i]->x, 
-                                (list[i]->y = m->y + (m->h * list[i]->yp) + list[i]->gapy), 
-                                list[i]->w, 
-                                (list[i]->h = (m->h * list[i]->hp) - 2*BORDER_WIDTH - list[i]->gapy - list[i]->gaph));
-                setclientborders(d, list[i], m);
-            }
+    if (current->isfullscrn)
+        setfullscreen(current, False);
+    if (!current->isfloating)
+        float_client(current);
+    tile();
+    update_current(current);
+
+    xcb_generic_event_t *e = NULL;
+    xcb_motion_notify_event_t *ev = NULL;
+    bool ungrab = false;
+    do {
+        xcb_flush(dis);
+        while (!(e = xcb_wait_for_event(dis)))
+            xcb_flush(dis);
+        switch (e->response_type & ~0x80) {
+            case XCB_CONFIGURE_REQUEST: case XCB_MAP_REQUEST:
+                events[e->response_type & ~0x80](e);
+                break;
+            case XCB_MOTION_NOTIFY:
+                ev = (xcb_motion_notify_event_t *)e;
+                xw = (arg->i == MOVE ? winx : winw) + ev->root_x - mx;
+                yh = (arg->i == MOVE ? winy : winh) + ev->root_y - my;
+                if (arg->i == RESIZE) xcb_resize(dis, current->win,
+                                      xw > MINWSZ ? xw : winw,
+                                      yh > MINWSZ ? yh : winh);
+                else if (arg->i == MOVE) xcb_move(dis, current->win, xw, yh);
+                xcb_flush(dis);
+                break;
+            case XCB_KEY_PRESS:
+            case XCB_KEY_RELEASE:
+            case XCB_BUTTON_PRESS:
+            case XCB_BUTTON_RELEASE:
+                ungrab = true;
         }
-        free(list);
-        DEBUG("tileremove: leaving\n");
-        return;
+        if (e)
+            free(e);
+    } while (!ungrab && current);
+    DEBUG("xcb: ungrab");
+    xcb_ungrab_pointer(dis, XCB_CURRENT_TIME);
+
+    free(pointer);
+}
+
+/* each window should cover all the available screen space */
+void monocle(int hh, int cy)
+{
+    unsigned int b = MONOCLE_BORDERS ? 2 * borders : 0;
+
+    for (client *c = head; c; c = c->next)
+        if (!ISFFTM(c))
+            xcb_move_resize(dis, c->win, gaps, cy + gaps,
+                            ww - 2 * gaps - b, hh - 2 * gaps - b);
+}
+
+/* move the current client, to current->next
+ * and current->next to current client's position */
+void move_down()
+{
+    /* p is previous, c is current, n is next, if current is head n is last */
+    client *p = NULL, *n = (current->next) ? current->next : head;
+    if (!(p = prev_client(current)))
+        return;
+    /*
+     * if c is head, swapping with n should update head to n
+     * [c]->[n]->..  ==>  [n]->[c]->..
+     *  ^head              ^head
+     *
+     * else there is a previous client and p->next should be what's after c
+     * ..->[p]->[c]->[n]->..  ==>  ..->[p]->[n]->[c]->..
+     */
+    if (current == head)
+        head = n;
+    else
+        p->next = current->next;
+    /*
+     * if c is the last client, c will be the current head
+     * [n]->..->[p]->[c]->NULL  ==>  [c]->[n]->..->[p]->NULL
+     *  ^head                         ^head
+     * else c will take the place of n, so c-next will be n->next
+     * ..->[p]->[c]->[n]->..  ==>  ..->[p]->[n]->[c]->..
+     */
+    current->next = (current->next) ? n->next : n;
+    /*
+     * if c was swapped with n then they now point to the same ->next.
+     * n->next should be c
+     * ..->[p]->[c]->[n]->..  ==>  ..->[p]->[n]->..  ==>  ..->[p]->[n]->[c]->..
+     *                                        [c]-^
+     *
+     * else c is the last client and n is head,
+     * so c will be move to be head, no need to update n->next
+     * [n]->..->[p]->[c]->NULL  ==>  [c]->[n]->..->[p]->NULL
+     *  ^head                         ^head
+     */
+    if (current->next == n->next)
+        n->next = current;
+    else
+        head = current;
+    tile();
+}
+
+/* move the current client, to the previous from current and
+ * the previous from  current to current client's position */
+void move_up()
+{
+    client *pp = NULL, *p;
+    /* p is previous from current or last if current is head */
+    if (!(p = prev_client(current)))
+        return;
+    /* pp is previous from p, or null if current is head and thus p is last */
+    if (p->next)
+        for (pp = head; pp && pp->next != p; pp = pp->next);
+    /*
+     * if p has a previous client then the next client should be current
+     * (current is c)
+     * ..->[pp]->[p]->[c]->..  ==>  ..->[pp]->[c]->[p]->..
+     *
+     * if p doesn't have a previous client, then p might be head, so head must
+     * change to c
+     * [p]->[c]->..  ==>  [c]->[p]->..
+     *  ^head              ^head
+     * if p is not head, then c is head (and p is last), so the new head is
+     * next of c
+     * [c]->[n]->..->[p]->NULL  ==>  [n]->..->[p]->[c]->NULL
+     *  ^head         ^last           ^head         ^last
+     */
+    if (pp)
+        pp->next = current;
+    else
+        head = (current == head) ? current->next : current;
+    /*
+     * next of p should be next of c
+     * ..->[pp]->[p]->[c]->[n]->..  ==>  ..->[pp]->[c]->[p]->[n]->..
+     * except if c was head (now c->next is head), so next of p should be c
+     * [c]->[n]->..->[p]->NULL  ==>  [n]->..->[p]->[c]->NULL
+     *  ^head         ^last           ^head         ^last
+     */
+    p->next = (current->next == head) ? current : current->next;
+    /*
+     * next of c should be p
+     * ..->[pp]->[p]->[c]->[n]->..  ==>  ..->[pp]->[c]->[p]->[n]->..
+     * except if c was head (now c->next is head), so c is must be last
+     * [c]->[n]->..->[p]->NULL  ==>  [n]->..->[p]->[c]->NULL
+     *  ^head         ^last           ^head         ^last
+     */
+    current->next = (current->next == head) ? NULL : p;
+    tile();
+}
+
+/* cyclic focus the next window
+ * if the window is the last on stack, focus head */
+void next_win()
+{
+    client *t = current;
+
+    if (!current || !head->next)
+        return;
+
+    while (1) {
+        if (!t->next)
+            t = head;
+        else
+            t = t->next;
+        if (!t->isminimized)
+            break;
+        if (t == current)
+            break;
     }
-    
-    if (findtouchingclients[TRIGHT](d, dead, list, &n)) {
-        // clients in list should gain the emptyspace
-        for (int i = 0; i < n; i++) {
-            list[i]->xp = dead->xp;
-            list[i]->wp += dead->wp;
-            if (m != NULL && (d->mode == TILE || d->mode == FLOAT)) {
-                adjustclientgaps(gap, list[i]);
-                xcb_move_resize(dis, list[i]->win, 
-                                (list[i]->x = m->x + (m->w * list[i]->xp) + list[i]->gapx), 
-                                list[i]->y, 
-                                (list[i]->w = (m->w * list[i]->wp) - 2*BORDER_WIDTH - list[i]->gapx - list[i]->gapw), 
-                                list[i]->h);
-                setclientborders(d, list[i], m);
-            }
-        }
-        free(list);
-        DEBUG("tileremove: leaving\n");
+
+    prevfocus = current;
+    update_current(t);
+}
+
+/* get the previous client from the given
+ * if no such client, return NULL */
+client *prev_client(client *c)
+{
+    if (!c || !head->next)
+        return NULL;
+    client *p;
+    for (p = head; p->next && p->next != c; p = p->next);
+    return p;
+}
+
+/* cyclic focus the previous window
+ * if the window is the head, focus the last stack window */
+void prev_win()
+{
+    client *t = current;
+
+    if (!current || !head->next)
         return;
+
+    while (1) {
+        t = prev_client(t);
+        if (!t->isminimized)
+            break;
+        if (t == current)
+            break;
     }
 
-    free(list);
-    DEBUG("tileremove: leaving, nothing tiled\n");
+    prevfocus = current;
+    update_current(t);
 }
 
-// 4WM 
-
-static char *WM_ATOM_NAME[]   = { "WM_PROTOCOLS", "WM_DELETE_WINDOW" };
-static char *NET_ATOM_NAME[]  = { "_NET_SUPPORTED", "_NET_WM_STATE_FULLSCREEN", "_NET_WM_STATE", "_NET_WM_NAME", "_NET_ACTIVE_WINDOW" };
+/* property notify is called when one of the window's properties
+ * is changed, such as an urgent hint is received
+ */
+void propertynotify(xcb_generic_event_t *e)
+{
+    xcb_property_notify_event_t *ev = (xcb_property_notify_event_t *)e;
+    xcb_icccm_wm_hints_t wmh;
+    client *c;
 
-#define USAGE           "usage: 4wm [-h] [-v]"
+    DEBUG("xcb: property notify");
+    c = wintoclient(ev->window);
+    if (!c || ev->atom != XCB_ICCCM_WM_ALL_HINTS)
+        return;
+    DEBUG("xcb: got hint!");
+    if (xcb_icccm_get_wm_hints_reply(dis,
+                                     xcb_icccm_get_wm_hints(dis, ev->window),
+                                                            &wmh, NULL))
+                                     /* TODO: error handling */
+        c->isurgent = c != current &&
+                           (wmh.flags & XCB_ICCCM_WM_HINT_X_URGENCY);
+    desktopinfo();
+}
 
-// get screen of display
-static xcb_screen_t *xcb_screen_of_display(xcb_connection_t *con, int screen) {
-    xcb_screen_iterator_t iter;
-    iter = xcb_setup_roots_iterator(xcb_get_setup(con));
-    for (; iter.rem; --screen, xcb_screen_next(&iter)) if (screen == 0) return iter.data;
-    return NULL;
+/* to quit just stop receiving events
+ * run() is stopped and control is back to main()
+ */
+void quit(const Arg *arg)
+{
+    retval = arg->i;
+    running = false;
 }
 
-// retieve RGB color from hex (think of html)
-static unsigned int xcb_get_colorpixel(char *hex) {
-    char strgroups[3][3]  = {{hex[1], hex[2], '\0'}, {hex[3], hex[4], '\0'}, {hex[5], hex[6], '\0'}};
-    unsigned int rgb16[3] = {(strtol(strgroups[0], NULL, 16)), (strtol(strgroups[1], NULL, 16)), (strtol(strgroups[2], NULL, 16))};
-    return (rgb16[0] << 16) + (rgb16[1] << 8) + rgb16[2];
+/* remove the specified client
+ *
+ * note, the removing client can be on any desktop,
+ * we must return back to the current focused desktop.
+ * if c was the previously focused, prevfocus must be updated
+ * else if c was the current one, current must be updated. */
+void removeclient(client *c)
+{
+    client **p = NULL;
+    int nd = 0, cd = current_desktop;
+
+    for (bool found = false; nd < DESKTOPS && !found; nd++)
+        for (select_desktop(nd), p = &head; *p && !(found = *p == c);
+             p = &(*p)->next);
+    *p = c->next;
+    if (c == prevfocus)
+        prevfocus = prev_client(current);
+    if (c == current || !head->next)
+        update_current(prevfocus);
+    free(c);
+    c = NULL;
+    if (cd == nd - 1)
+        tile();
+    else
+        select_desktop(cd);
 }
 
-// wrapper to get atoms using xcb
-static void xcb_get_atoms(char **names, xcb_atom_t *atoms, unsigned int count) {
-    xcb_intern_atom_cookie_t cookies[count];
-    xcb_intern_atom_reply_t  *reply;
+/* resize the master window - check for boundary size limits
+ * the size of a window can't be less than MINWSZ
+ */
+void resize_master(const Arg *arg)
+{
+    int msz = (mode == BSTACK ? wh : ww) * MASTER_SIZE + master_size + arg->i;
 
-    for (unsigned int i = 0; i < count; i++) cookies[i] = xcb_intern_atom(dis, 0, strlen(names[i]), names[i]);
-    for (unsigned int i = 0; i < count; i++) {
-        reply = xcb_intern_atom_reply(dis, cookies[i], NULL); // TODO: Handle error
-        if (reply) {
-            DEBUGP("%s : %d\n", names[i], reply->atom);
-            atoms[i] = reply->atom; free(reply);
-        } else puts("WARN: 4wm failed to register %s atom.\nThings might not work right.");
-    }
+    if (msz < MINWSZ || (mode == BSTACK ? wh : ww) - msz < MINWSZ)
+        return;
+    master_size += arg->i;
+    tile();
 }
 
-// check if other wm exists
-static int xcb_checkotherwm(void) {
-    xcb_generic_error_t *error;
-    unsigned int values[1] = {XCB_EVENT_MASK_SUBSTRUCTURE_REDIRECT|XCB_EVENT_MASK_SUBSTRUCTURE_NOTIFY|
-                              XCB_EVENT_MASK_PROPERTY_CHANGE|XCB_EVENT_MASK_BUTTON_PRESS};
-    error = xcb_request_check(dis, xcb_change_window_attributes_checked(dis, screen->root, XCB_CW_EVENT_MASK, values));
-    xcb_flush(dis);
-    if (error) return 1;
-    return 0;
+/* resize the first stack window - no boundary checks */
+void resize_stack(const Arg *arg)
+{
+    growth += arg->i;
+    tile();
 }
 
+/*
+ * resize floating windows in x-dimension (and float them if not already)
+ */
+void resize_x(const Arg *arg)
+{
+    xcb_get_geometry_reply_t *r;
 
-// remove all windows in all desktops by sending a delete message
-static void cleanup(void) {
-    DEBUG("cleanup: entering\n");
-    xcb_query_tree_reply_t  *query;
-    xcb_window_t *c;
+    if (!arg->i || !current)
+        return;
 
-    xcb_ungrab_key(dis, XCB_GRAB_ANY, screen->root, XCB_MOD_MASK_ANY);
-    if ((query = xcb_query_tree_reply(dis,xcb_query_tree(dis,screen->root),0))) {
-        c = xcb_query_tree_children(query);
-        for (unsigned int i = 0; i != query->children_len; ++i) deletewindow(c[i]);
-        free(query);
+    if (!current->isfloating) {
+        float_client(current);
+        tile();
     }
-    
-    // free each monitor
-    monitor *m, *t;
-    for (m = mons; m; m = t){
-        t = m->next;
-        free(m);
-    }
-
-    for (unsigned int i = 0; i < DESKTOPS; i++)
-        for (client *cl = desktops[i].head, *next; cl; cl = next){
-            next = cl->next;
-            free(cl);
-        }
-    #if MENU
-    // free each menu and each menuentry
-    Menu *men, *tmen;
-    Menu_Entry *ent, *tent;
-    for (men = menus; men; men = tmen) {
-        tmen = men->next;
-        for (ent = men->head; ent; ent = tent) {
-            tent = ent->next;
-            free(ent);
-        }
-        free(men);
-    }
-    #endif
-    #if PRETTY_PRINT
-    free(pp.ws);
-    free(pp.mode);
-    free(pp.dir);
-    //fclose(pp_in);
-    //fclose(pp_out);
-    #endif
-    xcb_set_input_focus(dis, XCB_INPUT_FOCUS_POINTER_ROOT, screen->root, XCB_CURRENT_TIME);
-    //xcb_flush(dis);
-    DEBUG("cleanup: leaving\n");
-}
-
-#if MENU
-static Menu_Entry* createmenuentry(int x, int y, int w, int h, char *cmd) {
-    DEBUG("createmenuentry: entering\n");
-    Menu_Entry *m = (Menu_Entry*)malloc_safe(sizeof(Menu_Entry));
-    
-    m->cmd[0] = cmd;
-    m->cmd[1] = NULL; 
-    m->rectangles = (xcb_rectangle_t*)malloc_safe(sizeof(xcb_rectangle_t));
-    m->x = m->rectangles->x = x;
-    m->y = m->rectangles->y = y;
-    m->rectangles->width = w;
-    m->rectangles->height = h;
-    m->next = m->b = m->l = m->r = m->t = NULL;
-    // we might also want to save coordinates for the string to print
-    DEBUG("createmenuentry: leaving\n");
-    return m;
-}
-
-static Menu* createmenu(char **list) {
-    DEBUG("createmenu: entering\n");
-    Menu *m = (Menu*)malloc_safe(sizeof(Menu));
-    Menu_Entry *mentry, *sentry = NULL, *itr = NULL;
-    int i, x, y;
-
-    m->list = list;
-    for (i = 0; list[i]; i++) {
-        if (!m->head) {
-            mentry = createmenuentry(selmon->w/2 - 50, selmon->h/2 - 30, 100, 60, list[i]);
-            m->head = itr = sentry = mentry;
-        } else {
-            if (sentry->l && sentry->t && !sentry->b) {
-                x = sentry->x;
-                y = sentry->y + 60;
-                DEBUGP("createmenu: x %d y %d \n", x, y);
-                mentry = createmenuentry(x, y, 100, 60, list[i]);
-                sentry->b = itr->next = mentry;
-                mentry->t = sentry;
-                itr = itr->next;
-                if (sentry->r) {
-                    if (!sentry->r->r) sentry = sentry->r;
-                    else if (sentry->r->b) {
-                        sentry->r->b->l = mentry;
-                        mentry->r = sentry->r->b;
-                        sentry = sentry->r->b;
-                    }
-                } 
-            } else if (sentry->t && !sentry->l) {
-                x = sentry->x - 100;
-                y = sentry->y;
-                DEBUGP("createmenu: x %d y %d \n", x, y);
-                mentry = createmenuentry(x, y, 100, 60, list[i]);
-                sentry->l = itr->next = mentry;
-                mentry->r = sentry;
-                itr = itr->next;
-                if (sentry->b && sentry->b->l) {
-                    sentry->b->l->t = mentry;
-                    mentry->b = sentry->b->l;
-                    sentry = sentry->b->l;
-                }
-            } else if (sentry->r && !sentry->t) {
-                x = sentry->x;
-                y = sentry->y - 60;
-                DEBUGP("createmenu: x %d y %d \n", x, y);
-                mentry = createmenuentry(x, y, 100, 60, list[i]);
-                sentry->t = itr->next = mentry;
-                mentry->b = sentry;
-                itr = itr->next;
-                if (sentry->l && sentry->l->t) {
-                    sentry->l->t->r = mentry;
-                    mentry->l = sentry->l->t;
-                    sentry = sentry->l->t;
-                }
-            } else if (!sentry->r) { 
-                x = sentry->x + 100;
-                y = sentry->y;
-                DEBUGP("createmenu: x %d y %d \n", x, y);
-                mentry = createmenuentry(x, y, 100, 60, list[i]);
-                sentry->r = itr->next = mentry;
-                mentry->l = sentry;
-                itr = itr->next;
-                if (sentry->t && sentry->t->r) {
-                    sentry->t->r->b = mentry;
-                    mentry->t = sentry->t->r;
-                    while (sentry->r) {
-                        sentry = sentry->r;
-                        if (sentry->t) sentry = sentry->t;
-                    }
-                }
-            } 
-        }
-    }
-    m->next = NULL;
-    DEBUG("createmenu: leaving\n");
-    return m;
-}
-#endif
 
-static monitor* createmon(xcb_randr_output_t id, int x, int y, int w, int h, int dtop) {
-    DEBUG("createmon: entering\n");
-    monitor *m = (monitor*)malloc_safe(sizeof(monitor));
-    
-    m->id = id;
-    m->curr_dtop = (dtop - 1);
-    m->haspanel = ((nmons == PANEL_MON) ? true:false);
-    m->x = x;
-    m->y = y + (m->haspanel && TOP_PANEL ? PANEL_HEIGHT:0);
-    m->w = w;
-    m->h = h - (m->haspanel && !TOP_PANEL ? PANEL_HEIGHT:0); 
-    m->next = NULL;
-    DEBUGP("createmon: creating monitor with x:%d y:%d w:%d h:%d desktop #:%d\n", m->x, m->y, m->w, m->h, (dtop - 1));
-    DEBUG("createmon: leaving\n");
-    return m;
-}
-
-// get a pixel with the requested color
-// to fill some window area - borders
-static unsigned int getcolor(char* color) {
-    xcb_colormap_t map = screen->default_colormap;
-    xcb_alloc_color_reply_t *c;
-    unsigned int r, g, b, rgb, pixel;
+    r = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win), NULL);
 
-    rgb = xcb_get_colorpixel(color);
-    r = rgb >> 16; g = rgb >> 8 & 0xFF; b = rgb & 0xFF;
-    c = xcb_alloc_color_reply(dis, xcb_alloc_color(dis, map, r * 257, g * 257, b * 257), NULL);
-    if (!c)
-        errx(EXIT_FAILURE, "error: cannot allocate color '%s'\n", color);
+    if (r->width + arg->i < MINWSZ || r->width + arg->i <= 0)
+        return;
 
-    pixel = c->pixel; free(c);
-    return pixel;
+    r->width += arg->i;
+    xcb_move_resize(dis, current->win, r->x, r->y, r->width, r->height);
 }
 
-static void getoutputs(xcb_randr_output_t *outputs, const int len, xcb_timestamp_t timestamp) {
-    DEBUG("getoutputs: entering\n");
-    // Walk through all the RANDR outputs (number of outputs == len) there
-    // was at time timestamp.
-    xcb_randr_get_crtc_info_cookie_t icookie;
-    xcb_randr_get_crtc_info_reply_t *crtc = NULL;
-    xcb_randr_get_output_info_reply_t *output;
-    xcb_randr_get_output_info_cookie_t ocookie[len];
-    monitor *m;
-    int i, n;
-    bool flag;
- 
-    // get output cookies
-    for (i = 0; i < len; i++) 
-        ocookie[i] = xcb_randr_get_output_info(dis, outputs[i], timestamp);
-
-    for (i = 0; i < len; i ++) { /* Loop through all outputs. */
-        output = xcb_randr_get_output_info_reply(dis, ocookie[i], NULL);
+/*
+ * resize floating windows in y-dimension (and float them if not already)
+ */
+void resize_y(const Arg *arg)
+{
+    xcb_get_geometry_reply_t *r;
 
-        if (output == NULL) 
-            continue;
-        //asprintf(&name, "%.*s",xcb_randr_get_output_info_name_length(output),xcb_randr_get_output_info_name(output));
+    if (!arg->i || !current)
+        return;
 
-        if (XCB_NONE != output->crtc) {
-            icookie = xcb_randr_get_crtc_info(dis, output->crtc, timestamp);
-            crtc    = xcb_randr_get_crtc_info_reply(dis, icookie, NULL);
-
-            if (NULL == crtc) 
-                return; 
-
-            flag = true;
-
-            //check for uniqeness or update old
-            for (n = 0, m = mons; m; m = m->next, n++) {
-                if (outputs[i] == m->id) {
-                    flag = false;
-                    //if they are the same check to see if the dimensions have
-                    //changed. and retile
-                    DEBUGP("%d %d %d %d %d %d %d %d\n", crtc->x, m->x,(crtc->y + ((SHOW_PANEL && TOP_PANEL) ? PANEL_HEIGHT:0)), 
-                            m->y, crtc->width, m->w, (crtc->height - (SHOW_PANEL ? PANEL_HEIGHT:0)), m->h);
-                    if (crtc->x != m->x||(crtc->y + ((SHOW_PANEL && TOP_PANEL) ? PANEL_HEIGHT:0)) != m->y||
-                        crtc->width != m->w|| (crtc->height - (SHOW_PANEL ? PANEL_HEIGHT:0)) != m->h) {
-                        DEBUG("getoutputs: adjusting monitor\n");
-                        m->x = crtc->x;
-                        m->y = crtc->y;
-                        m->w = crtc->width;
-                        m->h = crtc->height;
-                        retile(&desktops[m->curr_dtop], m);
-                    }
-                    break;
-                }
-            }
-            // if unique, add it to the list, give it a desktop/workspace
-            if (flag){
-                DEBUG("getoutputs: adding monitor\n");
-                for(m = mons; m && m->next; m = m->next);
-                if(m) {
-                    DEBUG("getoutputs: entering m->next = createmon\n");
-                    m->next = createmon(outputs[i], crtc->x, crtc->y, crtc->width, crtc->height, ++nmons);
-                }
-                else {
-                    DEBUG("getoutputs: entering mon = createmon\n");
-                    mons = createmon(outputs[i], crtc->x, crtc->y, crtc->width, crtc->height, ++nmons);
-                }
-            }
-        }
-        else {
-            //find monitor and delete
-            for (m = mons; m; m = m->next) {
-                if (m->id == outputs[i]) { //monitor found
-                    if (m == mons)
-                        mons = mons->next;
-                    if (m == selmon)
-                        selmon = mons;
-                    DEBUG("getoutputs: deleting monitor\n");
-                    free(m);
-                    nmons--;
-                    break;
-                } 
-            }
-        }
-        free(output);
+    if (!current->isfloating) {
+        float_client(current);
+        tile();
     }
-    DEBUG("getoutputs: leaving\n");
+
+    r = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, current->win), NULL);
+
+    if (r->height + arg->i < MINWSZ || r->height + arg->i <= 0)
+        return;
+
+    r->height += arg->i;
+    xcb_move_resize(dis, current->win, r->x, r->y, r->width, r->height);
 }
 
-static void getrandr(void) { // Get RANDR resources and figure out how many outputs there are.
-    xcb_randr_get_screen_resources_current_cookie_t rcookie = xcb_randr_get_screen_resources_current(dis, screen->root);
-    xcb_randr_get_screen_resources_current_reply_t *res = xcb_randr_get_screen_resources_current_reply(dis, rcookie, NULL);
-    if (NULL == res) return;
-    xcb_timestamp_t timestamp = res->config_timestamp;
-    int len     = xcb_randr_get_screen_resources_current_outputs_length(res);
-    xcb_randr_output_t *outputs = xcb_randr_get_screen_resources_current_outputs(res);
-    /* Request information for all outputs. */
-    getoutputs(outputs, len, timestamp);
-    free(res);
-}
-
-#if MENU
-static void initializexresources() {
-    //we should also go ahead and intitialize all the font gc's
-    uint32_t            value_list[3];
-    uint32_t            gcvalues[2];
-    xcb_void_cookie_t   cookie_font;
-    xcb_void_cookie_t   cookie_gc;
-    xcb_generic_error_t *error;
-    xcb_font_t          font;
-    uint32_t            mask, font_mask;
-    xcb_drawable_t      win = screen->root;
-    XrmValue value;
-    char *str_type[20];
-    char buffer[20];
-    char *names[] = { "*color1", "*color2",  "*color3", "*color4", "*color5", "*color6", 
-                    "*color9", "*color10", "*color11", "*color12", "*color13", "*color14", NULL };
-    char *class[] = { "*Color1", "*Color2",  "*Color3", "*Color4", "*Color5", "*Color6", 
-                    "*Color9", "*Color10", "*Color11", "*Color12", "*Color13", "*Color14", NULL };
-    struct passwd *pw = getpwuid(getuid());
-    char *xdefaults = pw->pw_dir;
-    strcat(xdefaults, "/.Xdefaults");
-
-    // initialize font
-    // TODO: user font
-    font = xcb_generate_id (dis);
-    cookie_font = xcb_open_font_checked (dis, font, strlen ("7x13"), "7x13");
-    error = xcb_request_check (dis, cookie_font);
-    if (error) {
-        fprintf (stderr, "ERROR: can't open font : %d\n", error->error_code);
-        xcb_disconnect (dis);
-    }
-
-    // initialize some values used to get the font gc's
-    font_mask = XCB_GC_FOREGROUND | XCB_GC_BACKGROUND | XCB_GC_FONT;
-    value_list[0] = screen->black_pixel;
-    value_list[2] = font;
-    // initialize some values for foreground gc's
-    mask = XCB_GC_FOREGROUND | XCB_GC_GRAPHICS_EXPOSURES;
-    gcvalues[1] = 0;
-
-    // initialize Xresources
-    XrmInitialize();
-    XrmDatabase dbase = XrmGetFileDatabase(xdefaults);
-
-    for(int i = 0; i < 12; i++) {
-        // now get all the colors from xresources and make the gc's
-        if (XrmGetResource(dbase, names[i], class[i], str_type, &value)) {
-            // getting color
-            strncpy(buffer, value.addr, (int) value.size);
-            xres.color[i] = getcolor(buffer);
-            
-            // getting rectangle foreground colors
-            xres.gc_color[i] = xcb_generate_id(dis);
-            gcvalues[0] = xres.color[i];
-            xcb_create_gc (dis, xres.gc_color[i], win, mask, gcvalues);
-            
-            // getting font gc
-            xres.font_gc[i] = xcb_generate_id(dis);
-            value_list[1] = xres.color[i];
-            cookie_gc = xcb_create_gc_checked (dis, xres.font_gc[i], win, font_mask, value_list);
-            error = xcb_request_check (dis, cookie_gc);
-            if (error) {
-                fprintf (stderr, "ERROR: can't create gc : %d\n", error->error_code);
-                xcb_disconnect (dis);
-                exit (-1);
-            } 
-        }
-    } 
-
-    cookie_font = xcb_close_font_checked (dis, font);
-    error = xcb_request_check (dis, cookie_font);
-    if (error) {
-        fprintf (stderr, "ERROR: can't close font : %d\n", error->error_code);
-        xcb_disconnect (dis);
-        exit (-1);
+/* get the last client from the current miniq and restore it */
+void restore()
+{
+    filo *tmp;
+
+    if (!miniq[current_desktop]->c)
+        return;
+
+    /* find the last occupied filo, before the free one */
+    tmp = miniq[current_desktop];
+    while (tmp->next) {
+        if (!tmp->next->next)
+            break;
+        tmp = tmp->next;
     }
+
+    free(tmp->next);
+    tmp->next = NULL;
+    tmp->c->isminimized = false;
+
+    /*
+     * if our window is floating, center it to move it back onto the visible
+     * screen, TODO: save geometry in some way to restore it where it was
+     * before minimizing, TODO: fix it to use centerwindow() instead of copying
+     * half of it
+     */
+    if (tmp->c->isfloating) {
+        xcb_get_geometry_reply_t *wa;
+        wa = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, tmp->c->win),
+                                    NULL);
+        xcb_raise_window(dis, tmp->c->win);
+        xcb_move(dis, tmp->c->win, (ww - wa->width) / 2, (wh - wa->height) / 2);
+        free(wa);
+    }
+    tile();
+    update_current(tmp->c);
+    tmp->c = NULL;
+}
+
+/* jump and focus the next or previous desktop */
+void rotate(const Arg *arg)
+{
+    change_desktop(&(Arg)
+                   {.i = (DESKTOPS + current_desktop + arg->i) % DESKTOPS});
+}
+
+/* jump and focus the next or previous desktop
+ * and take the current client with us. */
+void rotate_client(const Arg *arg)
+{
+    int i = (DESKTOPS + current_desktop + arg->i) % DESKTOPS;
+
+    client_to_desktop(&(Arg){.i = i});
+    change_desktop(&(Arg){.i = i});
+}
+
+/* jump and focus the next or previous desktop that has clients */
+void rotate_filled(const Arg *arg)
+{
+    int n = arg->i;
+
+    while (n < DESKTOPS && !desktops[(DESKTOPS + current_desktop + n) %
+                                     DESKTOPS].head)
+        (n += arg->i);
+    change_desktop(&(Arg){.i = (DESKTOPS + current_desktop + n) % DESKTOPS});
 }
-#endif
 
-// main event loop - on receival of an event call the appropriate event handler
-static void run(void) {
-    DEBUG("run: entered\n");
-    xcb_generic_event_t *ev; 
+/*
+ * main event loop - on receival of an event call the appropriate event
+ * handler
+ */
+void run(void)
+{
+    xcb_generic_event_t *ev;
+
     while(running) {
-        DEBUG("run: running\n");
         xcb_flush(dis);
-        if (xcb_connection_has_error(dis)) {
-            DEBUG("run: x11 connection got interrupted\n");
+        if (xcb_connection_has_error(dis))
             err(EXIT_FAILURE, "error: X11 connection got interrupted\n");
-        }
         if ((ev = xcb_wait_for_event(dis))) {
-            if (ev->response_type==randrbase + XCB_RANDR_SCREEN_CHANGE_NOTIFY) {
-                DEBUG("run: entering getrandr()\n");
-                getrandr();
-            }
             if (events[ev->response_type & ~0x80]) {
-                DEBUGP("run: entering event %d\n", ev->response_type & ~0x80);
                 events[ev->response_type & ~0x80](ev);
+            } else {
+                DEBUGP("xcb: unimplented event: %d\n",
+                       ev->response_type & ~0x80);
             }
-            else {DEBUGP("xcb: unimplented event: %d\n", ev->response_type & ~0x80);}
             free(ev);
         }
     }
-    DEBUG("run: leaving\n");
 }
 
-// get numlock modifier using xcb
-static int setup_keyboard(void) {
+/* save specified desktop's properties */
+void save_desktop(int i)
+{
+    if (i < 0 || i >= DESKTOPS)
+        return;
+    desktops[i].master_size = master_size;
+    desktops[i].mode        = mode;
+    desktops[i].growth      = growth;
+    desktops[i].head        = head;
+    desktops[i].current     = current;
+    desktops[i].showpanel   = showpanel;
+    desktops[i].prevfocus   = prevfocus;
+    desktops[i].gaps        = gaps;
+    desktops[i].invert = invert;
+}
+
+/* set the specified desktop's properties */
+void select_desktop(int i)
+{
+    if (i < 0 || i >= DESKTOPS)
+        return;
+    save_desktop(current_desktop);
+    master_size     = desktops[i].master_size;
+    mode            = desktops[i].mode;
+    growth          = desktops[i].growth;
+    head            = desktops[i].head;
+    current         = desktops[i].current;
+    showpanel       = desktops[i].showpanel;
+    prevfocus       = desktops[i].prevfocus;
+    gaps            = desktops[i].gaps;
+    invert     = desktops[i].invert;
+    current_desktop = i;
+}
+
+/* set or unset fullscreen state of client */
+void setfullscreen(client *c, bool fullscrn)
+{
+    DEBUGP("xcb: set fullscreen: %d\n", fullscrn);
+    long data[] = { fullscrn ? netatoms[NET_FULLSCREEN] : XCB_NONE };
+
+    if (fullscrn != c->isfullscrn)
+        xcb_change_property(dis, XCB_PROP_MODE_REPLACE,
+                            c->win, netatoms[NET_WM_STATE], XCB_ATOM_ATOM, 32,
+                            fullscrn, data);
+    if ((c->isfullscrn = fullscrn))
+        xcb_move_resize(dis, c->win, 0, 0, ww, wh + PANEL_HEIGHT);
+    xcb_border_width(dis, c->win,
+                     (!head->next ||
+                      c->isfullscrn ||
+                      (mode == MONOCLE && !ISFFTM(c) && !MONOCLE_BORDERS)
+                     ) ? 0:borders);
+    update_current(c);
+}
+
+/* get numlock modifier using xcb */
+int setup_keyboard(void)
+{
     xcb_get_modifier_mapping_reply_t *reply;
     xcb_keycode_t                    *modmap;
     xcb_keycode_t                    *numlock;
 
-    reply   = xcb_get_modifier_mapping_reply(dis, xcb_get_modifier_mapping_unchecked(dis), NULL); /* TODO: error checking */
-    if (!reply) return -1;
+    reply = xcb_get_modifier_mapping_reply(dis,
+                            xcb_get_modifier_mapping_unchecked(dis), NULL);
+                            /* TODO: error checking */
+    if (!reply)
+        return -1;
 
     modmap = xcb_get_modifier_mapping_keycodes(reply);
-    if (!modmap) return -1;
+    if (!modmap) {
+        free(reply);
+        return -1;
+    }
 
     numlock = xcb_get_keycodes(XK_Num_Lock);
-    for (unsigned int i=0; i<8; i++)
-       for (unsigned int j=0; j<reply->keycodes_per_modifier; j++) {
-           xcb_keycode_t keycode = modmap[i * reply->keycodes_per_modifier + j];
-           if (keycode == XCB_NO_SYMBOL) continue;
-           for (unsigned int n=0; numlock[n] != XCB_NO_SYMBOL; n++)
-               if (numlock[n] == keycode) {
-                   DEBUGP("xcb: found num-lock %d\n", 1 << i);
-                   numlockmask = 1 << i;
-                   break;
-               }
-       }
+    for (unsigned int i = 0; i < 8; i++)
+       for (unsigned int j = 0; j < reply->keycodes_per_modifier; j++) {
+            xcb_keycode_t keycode = modmap[i * reply->keycodes_per_modifier +
+                                           j];
+            if (keycode == XCB_NO_SYMBOL)
+                continue;
+            for (unsigned int n = 0; numlock[n] != XCB_NO_SYMBOL; n++)
+                if (numlock[n] == keycode) {
+                    DEBUGP("xcb: found num-lock %d\n", 1 << i);
+                    numlockmask = 1 << i;
+                    break;
+                }
+        }
+    free(reply);
+    free(numlock);
 
     return 0;
 }
 
-static void sigchld() {
-    if (signal(SIGCHLD, sigchld) == SIG_ERR)
-        err(EXIT_FAILURE, "cannot install SIGCHLD handler");
-    while(0 < waitpid(-1, NULL, WNOHANG));
-}
+/* set initial values
+ * root window - screen height/width - atoms - xerror handler
+ * set masks for reporting events handled by the wm
+ * and propagate the suported net atoms
+ */
+int setup(int default_screen)
+{
+    xcb_intern_atom_cookie_t *cookie;
 
-static int setuprandr(void) { // Set up RANDR extension. Get the extension base and subscribe to
-    // events.
-    const xcb_query_extension_reply_t *extension = xcb_get_extension_data(dis, &xcb_randr_id);
-    if (!extension->present) return -1;
-    else getrandr();
-    int base = extension->first_event;
-    xcb_randr_select_input(dis, screen->root,XCB_RANDR_NOTIFY_MASK_SCREEN_CHANGE |
-            XCB_RANDR_NOTIFY_MASK_OUTPUT_CHANGE |XCB_RANDR_NOTIFY_MASK_CRTC_CHANGE |
-            XCB_RANDR_NOTIFY_MASK_OUTPUT_PROPERTY);
-    return base;
-}
-
-// set initial values
-// root window - screen height/width - atoms - xerror handler
-// set masks for reporting events handled by the wm
-// and propagate the suported net atoms
-static int setup(int default_screen) {
     sigchld();
     screen = xcb_screen_of_display(dis, default_screen);
-    if (!screen) err(EXIT_FAILURE, "error: cannot aquire screen\n");
-    
-    randrbase = setuprandr();
-    //DEBUG("exited setuprandr, continuing setup\n");
-
-    selmon = mons; 
-    for (unsigned int i=0; i<DESKTOPS; i++)
-        desktops[i] = (desktop){ .mode = DEFAULT_MODE, .direction = DEFAULT_DIRECTION, .showpanel = SHOW_PANEL, .gap = GAP, .count = 0, };
+    if (!screen)
+        err(EXIT_FAILURE, "error: cannot aquire screen\n");
 
-    win_focus   = getcolor(FOCUS);
-    win_unfocus = getcolor(UNFOCUS);
-    win_outer   = getcolor(OTRBRDRCOL);
-    win_urgent  = getcolor(URGNBRDRCOL);
-    win_flt     = getcolor(FLTBRDCOL);
-    win_trn     = getcolor(TRNBDRCOL);
-
-    #if MENU
-    // initialize the menu 
-    Menu *m = NULL;
-    Menu *itr = NULL;
-    char **menulist[] = MENUS;
-    for (int i = 0; menulist[i]; i++) {
-        m = createmenu(menulist[i]);
-        if (!menus)
-            menus = m;
-        else {
-            for (itr = menus; itr->next; itr = itr->next); 
-            itr->next = m;
-        }
+    ww = screen->width_in_pixels;
+    wh = screen->height_in_pixels - PANEL_HEIGHT;
+    borders = BORDER_WIDTH;
+    gaps = USELESSGAP;
+    for (unsigned int i = 0; i < DESKTOPS; i++) {
+        desktops[i].gaps = USELESSGAP;
+        save_desktop(i);
+        miniq[i] = calloc(1, sizeof(struct filo));
+        if (!miniq[i])
+            err(EXIT_FAILURE, "error: cannot allocate miniq\n");
     }
 
-    initializexresources();
-    #endif
+    win_focus   = getcolor(FOCUS);
+    win_unfocus = getcolor(UNFOCUS);
 
     /* setup keyboard */
     if (setup_keyboard() == -1)
@@ -2861,95 +2049,474 @@ static int setup(int default_screen) {
     if (xcb_checkotherwm())
         err(EXIT_FAILURE, "error: other wm is running\n");
 
-    xcb_change_property(dis, XCB_PROP_MODE_REPLACE, screen->root, netatoms[NET_SUPPORTED], XCB_ATOM_ATOM, 32, NET_COUNT, netatoms);
-    xcb_flush(dis);
+    /* initialize apprule regexes */
+    for (unsigned int i = 0; i < LENGTH(rules); i++)
+        if (regcomp(&appruleregex[i], rules[i].class, 0))
+            err(EXIT_FAILURE, "error: failed to compile apprule regexes\n");
+
+    /* initialize EWMH */
+    ewmh = calloc(1, sizeof(xcb_ewmh_connection_t));
+    if (!ewmh)
+        err(EXIT_FAILURE, "error: failed to set ewmh atoms\n");
+    cookie = xcb_ewmh_init_atoms(dis, ewmh);
+    xcb_ewmh_init_atoms_replies(ewmh, cookie, (void *)0);
+
+    /* set EWMH atoms */
+    xcb_atom_t net_atoms[] = { ewmh->_NET_SUPPORTED,
+                               ewmh->_NET_WM_STATE_FULLSCREEN,
+                               ewmh->_NET_WM_STATE,
+                               ewmh->_NET_SUPPORTING_WM_CHECK,
+                               ewmh->_NET_ACTIVE_WINDOW,
+                               ewmh->_NET_NUMBER_OF_DESKTOPS,
+                               ewmh->_NET_CURRENT_DESKTOP,
+                               ewmh->_NET_DESKTOP_GEOMETRY,
+                               ewmh->_NET_DESKTOP_VIEWPORT,
+                               ewmh->_NET_WORKAREA,
+                               ewmh->_NET_SHOWING_DESKTOP,
+                               ewmh->_NET_CLOSE_WINDOW,
+                               ewmh->_NET_WM_WINDOW_TYPE };
+
+    xcb_ewmh_coordinates_t viewports[2] = {{ 0, 0 }};
+    /* TODO: calculate workarea properly by substracting optional panel space */
+    xcb_ewmh_geometry_t workarea[2] = {{ 0, 0, ww, wh }};
+
+    xcb_ewmh_set_supported(ewmh, default_screen, NET_COUNT, net_atoms);
+    xcb_ewmh_set_supporting_wm_check(ewmh, default_screen, screen->root);
+    xcb_ewmh_set_number_of_desktops(ewmh, default_screen, DESKTOPS);
+    xcb_ewmh_set_current_desktop(ewmh, default_screen, DEFAULT_DESKTOP);
+    xcb_ewmh_set_desktop_geometry(ewmh, default_screen, ww, wh);
+    xcb_ewmh_set_desktop_viewport(ewmh, default_screen, 1, viewports);
+    xcb_ewmh_set_workarea(ewmh, default_screen, 1, workarea);
+    xcb_ewmh_set_showing_desktop(ewmh, default_screen, 0);
+
+    xcb_change_property(dis, XCB_PROP_MODE_REPLACE, screen->root,
+                        netatoms[NET_SUPPORTED], XCB_ATOM_ATOM, 32, NET_COUNT,
+                        netatoms);
     grabkeys();
 
     /* set events */
-    for (unsigned int i=0; i<XCB_NO_OPERATION; i++) events[i] = NULL;
-    events[XCB_BUTTON_PRESS]                = buttonpress;
-    events[XCB_CLIENT_MESSAGE]              = clientmessage;
-    events[XCB_CONFIGURE_REQUEST]           = configurerequest;
-    //events[XCB_CONFIGURE_NOTIFY]            = configurenotify;
-    events[XCB_DESTROY_NOTIFY]              = destroynotify;
-    events[XCB_ENTER_NOTIFY]                = enternotify;
-    #if PRETTY_PRINT
-    events[XCB_EXPOSE]                      = expose;
-    #endif
-    events[XCB_FOCUS_IN]                    = focusin;
-    events[XCB_KEY_PRESS|XCB_KEY_RELEASE]   = keypress;
-    events[XCB_MAPPING_NOTIFY]              = mappingnotify;
-    events[XCB_MAP_REQUEST]                 = maprequest;
-    events[XCB_PROPERTY_NOTIFY]             = propertynotify;
-    events[XCB_UNMAP_NOTIFY]                = unmapnotify;
-    events[XCB_NONE]                        = NULL;
-
-    //DEBUG("setup: about to switch to default desktop\n");
-    if (DEFAULT_DESKTOP >= 0 && DEFAULT_DESKTOP < DESKTOPS)
-        change_desktop(&(Arg){.i = DEFAULT_DESKTOP});
-    
-    // new pipe to messenger, panel, dzen
-    #if PRETTY_PRINT
-    updatews();
-    updatemode();
-    updatedir();
-    
-    int pfds[2];
-    pid_t pid;
-
-    if (pipe(pfds) < 0) {
-        perror("pipe failed");
-        return EXIT_FAILURE;
-    }
-
-    pid = fork();
-    if (pid < 0) {
-        perror("fork failed");
-        return EXIT_FAILURE;
-    } else if (pid == 0) { // child
-        close(pfds[0]); // close unused read end
-        // set write end of pipe as stdout for this child process
-        dup2(pfds[1], STDOUT_FILENO);
-        //pp_out = fdopen(pfds[1], "w");
-        close(pfds[1]);
-
-        desktopinfo();
-    } else /* if (pid > 0) */ { // parent
-        char *args[] = PP_CMD;
-        close(pfds[1]); // close unused write end
-        // set read end of pipe as stdin for this process
-        dup2(pfds[0], STDIN_FILENO);
-        //pp_in = fdopen(pfds[0], "r");
-        close(pfds[0]); // already redirected to stdin
-
-        execvp(args[0], args);
-        perror("exec failed");
-        exit(EXIT_FAILURE);
-    }
-    #endif
+    for (unsigned int i = 0; i < XCB_NO_OPERATION; i++)
+        events[i] = NULL;
+    events[XCB_BUTTON_PRESS]        = buttonpress;
+    events[XCB_CLIENT_MESSAGE]      = clientmessage;
+    events[XCB_CONFIGURE_REQUEST]   = configurerequest;
+    events[XCB_DESTROY_NOTIFY]      = destroynotify;
+    events[XCB_ENTER_NOTIFY]        = enternotify;
+    events[XCB_KEY_PRESS]           = keypress;
+    events[XCB_MAP_REQUEST]         = maprequest;
+    events[XCB_PROPERTY_NOTIFY]     = propertynotify;
+    events[XCB_UNMAP_NOTIFY]        = unmapnotify;
+
+    /* grab existing windows */
+    xcb_get_window_attributes_reply_t *attr;
+    xcb_query_tree_reply_t *reply = xcb_query_tree_reply(dis,
+                                        xcb_query_tree(dis, screen->root), 0);
+    if (reply) {
+        int len = xcb_query_tree_children_length(reply);
+        xcb_window_t *children = xcb_query_tree_children(reply);
+        for (int i = 0; i < len; i++) {
+            attr = xcb_get_window_attributes_reply(dis,
+                            xcb_get_window_attributes(dis, children[i]), NULL);
+            if (!attr)
+                continue;
+            /* ignore windows in override redirect mode as we won't see them */
+            if (!attr->override_redirect) {
+                addwindow(children[i]);
+                grabbuttons(wintoclient(children[i]));
+            }
+            free(attr);
+        }
+        free(reply);
+    }
+
+    change_desktop(&(Arg){.i = DEFAULT_DESKTOP});
+    switch_mode(&(Arg){.i = DEFAULT_MODE});
+
+    /* open the scratchpad terminal if enabled */
+    if (USE_SCRATCHPAD)
+        spawn(&(Arg){.com = scrpcmd});
 
-    DEBUG("leaving setup\n");
     return 0;
 }
 
-int main(int argc, char *argv[]) {
-    int default_screen;
+/*
+ * toggle visibility of all windows in all desktops
+ */
+void showhide(void)
+{
+    if ((show = !show)) {
+        tile();
+        if (show)
+            for (client *c = desktops[current_desktop].head; c; c = c->next)
+                xcb_map_window(dis, c->win);
+        xcb_ewmh_set_showing_desktop(ewmh, default_screen, 1);
+    } else {
+        for (client *c = desktops[current_desktop].head; c; c = c->next)
+            xcb_move(dis, c->win, -2 * ww, 0);
+        xcb_ewmh_set_showing_desktop(ewmh, default_screen, 0);
+    }
+}
+
+void sigchld()
+{
+    if (signal(SIGCHLD, sigchld) == SIG_ERR)
+        err(EXIT_FAILURE, "cannot install SIGCHLD handler");
+    while (0 < waitpid(-1, NULL, WNOHANG));
+}
+
+/* execute a command, save the child pid if we start the scratchpad */
+void spawn(const Arg *arg)
+{
+    if (fork())
+        return;
+    if (dis)
+        close(screen->root);
+    setsid();
+    execvp((char *)arg->com[0], (char **)arg->com);
+    fprintf(stderr, "error: execvp %s", (char *)arg->com[0]);
+    perror(" failed"); /* also prints the err msg */
+    exit(EXIT_SUCCESS);
+}
+
+/* arrange windows in normal or bottom stack tile */
+void stack(int hh, int cy)
+{
+    client *c = NULL, *t = NULL; bool b = mode == BSTACK;
+    int n = 0, d = 0, z = b ? ww : hh,
+        ma = (mode == BSTACK ? wh : ww) * MASTER_SIZE + master_size;
+
+    /* count stack windows and grab first non-floating, non-fullscreen window */
+    for (t = head; t; t = t->next) {
+        if (!ISFFTM(t)) {
+            if (c)
+                ++n;
+            else
+                c = t;
+        }
+    }
+
+    /*
+     * if there is only one window, it should cover the available screen space
+     * if there is only one stack window (n == 1) then we don't care about
+     * growth if more than one stack windows (n > 1) on screen then adjustments
+     * may be needed
+     *   - d is the num of pixels than remain when spliting
+     *   the available width/height to the number of windows
+     *   - z is the clients' height/width
+     *
+     *      ----------  -.    --------------------.
+     *      |   |----| --|--> growth               `}--> first client will get
+     *      |   |    |   |                          |    (z+d) height/width
+     *      |   |----|   }--> screen height - hh  --'
+     *      |   |    | }-|--> client height - z
+     *      ----------  -'
+     *
+     *     ->  piece of art by c00kiemon5ter o.O om nom nom nom nom
+     *
+     *     what we do is, remove the growth from the screen height   : (z -
+     *     growth) and then divide that space with the windows on the stack  :
+     *     (z - growth)/n so all windows have equal height/width (z)
+     *     : growth is left out and will later be added to the first's client
+     *     height/width before that, there will be cases when the num of
+     *     windows is not perfectly divided with then available screen
+     *     height/width (ie 100px scr. height, and 3 windows) so we get that
+     *     remaining space and merge growth to it (d) : (z - growth) % n +
+     *     growth finally we know each client's height, and how many pixels
+     *     should be added to the first stack window so that it satisfies
+     *     growth, and doesn't create gaps
+     *     on the bottom of the screen.
+     */
+    if (!c) {
+        return;
+    } else if (!n) {
+        xcb_move_resize(dis, c->win, gaps, cy + gaps,
+                        ww - 2 * (borders + gaps),
+                        hh - 2 * (borders + gaps));
+        return;
+    } else if (n > 1) {
+        d = (z - growth) % n + growth; z = (z - growth) / n;
+    }
+
+    /* tile the first non-floating, non-fullscreen window to cover the master area */
+    if (b)
+        xcb_move_resize(dis, c->win, gaps,
+                        invert ? (cy + hh - ma + gaps) : (cy + gaps),
+                        ww - 2 * (borders + gaps),
+                        ma - 2 * (borders + gaps));
+    else
+        xcb_move_resize(dis, c->win, invert ? (ww - ma + gaps) : gaps,
+                        cy + gaps,
+                        ma - 2 * (borders + gaps),
+                        hh - 2 * (borders + gaps));
+
+    /* tile the next non-floating, non-fullscreen (first) stack window with growth|d */
+    for (c = c->next; c && ISFFTM(c); c = c->next);
+    int cx = b ? 0 : (invert ? gaps : ma),
+        cw = (b ? hh : ww) - 2 * borders - ma - gaps,
+        ch = z - 2 * borders - gaps;
+    if (b)
+        xcb_move_resize(dis, c->win, cx += gaps, cy += invert ? gaps : ma,
+                        ch - gaps + d, cw);
+    else
+        xcb_move_resize(dis, c->win, cx, cy += gaps, cw, ch - gaps + d);
+
+    /* tile the rest of the non-floating, non-fullscreen stack windows */
+    for (b ? (cx += z + d - gaps) : (cy += z + d - gaps),
+         c = c->next; c; c = c->next) {
+        if (ISFFTM(c))
+            continue;
+        if (b) {
+            xcb_move_resize(dis, c->win, cx, cy, ch, cw); cx += z;
+        } else {
+            xcb_move_resize(dis, c->win, cx, cy, cw, ch); cy += z;
+        }
+    }
+}
+
+/* swap master window with current or
+ * if current is head swap with next
+ * if current is not head, then head
+ * is behind us, so move_up until we
+ * are the head */
+void swap_master()
+{
+    if (!current || !head->next)
+        return;
+    if (current == head)
+        move_down();
+    else
+        while (current != head)
+            move_up();
+    update_current(head);
+}
+
+/* switch the tiling mode and reset all floating windows */
+void switch_mode(const Arg *arg)
+{
+    if (!show)
+        showhide();
+    if (mode == arg->i)
+        for (client *c = head; c; c = c->next)
+            unfloat_client(c);
+    mode = arg->i;
+    tile();
+    update_current(current);
+    desktopinfo();
+}
+
+
+/* cycle the tiling mode and reset all floating windows */
+void rotate_mode(const Arg *arg)
+{
+    if (!show)
+        showhide();
+    mode = (mode + arg->i + MODES) % MODES;
+    tile();
+    update_current(current);
+    desktopinfo();
+}
+
+/* tile all windows of current desktop - call the handler tiling function */
+void tile(void)
+{
+    desktopinfo();
+    if (!head)
+        return; /* nothing to arange */
+    layout[head->next ? mode : MONOCLE](wh + (showpanel ? 0 : PANEL_HEIGHT),
+                                (TOP_PANEL && showpanel ? PANEL_HEIGHT : 0));
+}
+
+/* reset the active window from floating to tiling, if not already */
+void tilemize()
+{
+    if (!current || !current->isfloating)
+        return;
+    unfloat_client(current);
+    update_current(current);
+}
+
+/* toggle visibility state of the panel */
+void togglepanel()
+{
+    showpanel = !showpanel;
+    tile();
+}
+
+/*
+ * Toggle the scratchpad terminal, also attempt to reopen it if it is
+ * not present.
+ */
+void togglescratchpad()
+{
+    if (!USE_SCRATCHPAD) {
+        return;
+    } else if (!scrpd) {
+        spawn(&(Arg){.com = scrpcmd});
+        showscratchpad = false;
+        if (!scrpd)
+            return;
+    }
+
+    showscratchpad = !showscratchpad;
+
+    if (showscratchpad) {
+        xcb_get_geometry_reply_t *wa;
+
+        wa = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, scrpd->win),
+                                    NULL);
+        xcb_move(dis, scrpd->win, (ww - wa->width) / 2, (wh - wa->height) / 2);
+        update_current(scrpd);
+        xcb_raise_window(dis, scrpd->win);
+    } else {
+        xcb_move(dis, scrpd->win, -2 * ww, 0);
+        if (current == scrpd)
+            update_current(prevfocus->isminimized ? head : prevfocus);
+    }
+}
+
+/* tile a floating client and save its size for re-floating */
+void unfloat_client(client *c)
+{
+    xcb_get_geometry_reply_t *r;
+
+    if (!c)
+        return;
+
+    c->isfloating = false;
+
+    r = xcb_get_geometry_reply(dis, xcb_get_geometry(dis, c->win), NULL);
+    c->dim[0] = r->width;
+    c->dim[1] = r->height;
+    free(r);
+}
+
+/* windows that request to unmap should lose their
+ * client, so no invisible windows exist on screen
+ */
+void unmapnotify(xcb_generic_event_t *e)
+{
+    xcb_unmap_notify_event_t *ev = (xcb_unmap_notify_event_t *)e;
+    client *c = wintoclient(ev->window);
+    if (c && ev->event != screen->root)
+        removeclient(c);
+    desktopinfo();
+}
+
+/*
+ * highlight borders and set active window and input focus
+ * if given current is NULL then delete the active window property
+ *
+ * stack order by client properties, top to bottom:
+ *  - current when floating or transient
+ *  - floating or trancient windows
+ *  - current when tiled
+ *  - current when fullscreen
+ *  - fullscreen windows
+ *  - tiled windows
+ *
+ * a window should have borders in any case, except if
+ *  - the window is the only window on screen
+ *  - the window is fullscreen
+ *  - the mode is MONOCLE and the window is not floating or transient
+ *    and MONOCLE_BORDERS is set to false
+ */
+void update_current(client *c)
+{
+    if (!head) {
+        xcb_delete_property(dis, screen->root, netatoms[NET_ACTIVE]);
+        current = prevfocus = NULL;
+        return;
+    } else if (c == prevfocus) {
+        prevfocus = prev_client(current = prevfocus ? prevfocus : head);
+    } else if (c != current) {
+        prevfocus = current; current = c;
+    }
+
+    /* num of n:all fl:fullscreen ft:floating/transient windows */
+    int n = 0, fl = 0, ft = 0;
+    for (c = head; c; c = c->next, ++n)
+        if (ISFFTM(c)) {
+            fl++;
+            if (!c->isfullscrn)
+                ft++;
+        }
+    xcb_window_t w[n];
+    w[(current->isfloating || current->istransient) ? 0 : ft] = current->win;
+    for (fl += !ISFFTM(current) ? 1 : 0, c = head; c; c = c->next) {
+        xcb_change_window_attributes(dis, c->win, XCB_CW_BORDER_PIXEL,
+                                (c == current ? &win_focus : &win_unfocus));
+        xcb_border_width(dis, c->win,
+                         (c->isfullscrn ||
+                          (!MONOCLE_BORDERS && !head->next) ||
+                          (mode == MONOCLE && !ISFFTM(c) && !MONOCLE_BORDERS)
+                          ) ? 0 : borders);
+        /*
+         * if (CLICK_TO_FOCUS) xcb_grab_button(dis, 1, c->win,
+         *     XCB_EVENT_MASK_BUTTON_PRESS, XCB_GRAB_MODE_ASYNC,
+         *     XCB_GRAB_MODE_ASYNC, screen->root, XCB_NONE, XCB_BUTTON_INDEX_1,
+         *     XCB_BUTTON_MASK_ANY);
+         */
+        if (c != current)
+            w[c->isfullscrn ? --fl : ISFFTM(c) ? --ft : --n] = c->win;
+    }
+
+    /* restack */
+    if (!current->isfloating)
+        for (ft = 0; ft <= n; ++ft)
+            xcb_raise_window(dis, w[n-ft]);
+    else
+        xcb_raise_window(dis, current->win);
+
+    if (USE_SCRATCHPAD && showscratchpad && scrpd)
+        xcb_raise_window(dis, scrpd->win);
+
+    xcb_change_property(dis, XCB_PROP_MODE_REPLACE, screen->root,
+                        netatoms[NET_ACTIVE], XCB_ATOM_WINDOW, 32, 1,
+                        &current->win);
+    xcb_set_input_focus(dis, XCB_INPUT_FOCUS_POINTER_ROOT, current->win,
+                        XCB_CURRENT_TIME);
+    /* if (CLICK_TO_FOCUS) xcb_ungrab_button(dis, XCB_BUTTON_INDEX_1, XCB_NONE,
+    *                                        current->win); */
+    tile();
+}
+
+/* find to which client the given window belongs to */
+client *wintoclient(xcb_window_t w)
+{
+    client *c = NULL;
+    int d = 0, cd = current_desktop;
+    for (bool found = false; d < DESKTOPS && !found; ++d)
+        for (select_desktop(d), c = head; c && !(found = (w == c->win));
+             c = c->next);
+    if (cd != d-1)
+        select_desktop(cd);
+    return c;
+}
+
+int main(int argc, char *argv[])
+{
     if (argc == 2 && argv[1][0] == '-') switch (argv[1][1]) {
-        case 'v': errx(EXIT_SUCCESS, "%s - by Derek Taaffe", VERSION);
-        case 'h': errx(EXIT_SUCCESS, "%s", USAGE);
-        default: errx(EXIT_FAILURE, "%s", USAGE);
-    } else if (argc != 1) errx(EXIT_FAILURE, "%s", USAGE);
+        case 'v':
+            errx(EXIT_SUCCESS,
+            "%s - by sulami (thanks to c00kiemon5ter and Cloudef)",
+            VERSION);
+        case 'h':
+            errx(EXIT_SUCCESS, "%s", USAGE);
+        default:
+            errx(EXIT_FAILURE, "%s", USAGE);
+    } else if (argc != 1) {
+        errx(EXIT_FAILURE, "%s", USAGE);
+    }
     if (xcb_connection_has_error((dis = xcb_connect(NULL, &default_screen))))
         errx(EXIT_FAILURE, "error: cannot open display\n");
     if (setup(default_screen) != -1) {
-      #if PRETTY_PRINT
-      desktopinfo(); // zero out every desktop on (re)start
-      #endif
-      run();
+        desktopinfo(); /* zero out every desktop on (re)start */
+        run();
     }
     cleanup();
     xcb_disconnect(dis);
     return retval;
 }
 
-/* vim: set ts=4 sw=4 :*/
+/* vim: set ts=4 sw=4 expandtab :*/
+
